<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<!-- NewPage -->
<html lang="en">
<head>
<!-- Generated by javadoc (1.8.0_65) on Wed Jan 20 02:13:44 PST 2016 -->
<title>TregexPattern (Stanford JavaNLP API)</title>
<meta name="date" content="2016-01-20">
<link rel="stylesheet" type="text/css" href="../../../../../stylesheet.css" title="Style">
<script type="text/javascript" src="../../../../../script.js"></script>
</head>
<body>
<script type="text/javascript"><!--
    try {
        if (location.href.indexOf('is-external=true') == -1) {
            parent.document.title="TregexPattern (Stanford JavaNLP API)";
        }
    }
    catch(err) {
    }
//-->
var methods = {"i0":9,"i1":9,"i2":10,"i3":10,"i4":10,"i5":10,"i6":10,"i7":10,"i8":9,"i9":6};
var tabs = {65535:["t0","All Methods"],1:["t1","Static Methods"],2:["t2","Instance Methods"],4:["t3","Abstract Methods"],8:["t4","Concrete Methods"]};
var altColor = "altColor";
var rowColor = "rowColor";
var tableTab = "tableTab";
var activeTableTab = "activeTableTab";
</script>
<noscript>
<div>JavaScript is disabled on your browser.</div>
</noscript>
<!-- ========= START OF TOP NAVBAR ======= -->
<div class="topNav"><a name="navbar.top">
<!--   -->
</a>
<div class="skipNav"><a href="#skip.navbar.top" title="Skip navigation links">Skip navigation links</a></div>
<a name="navbar.top.firstrow">
<!--   -->
</a>
<ul class="navList" title="Navigation">
<li><a href="../../../../../overview-summary.html">Overview</a></li>
<li><a href="package-summary.html">Package</a></li>
<li class="navBarCell1Rev">Class</li>
<li><a href="package-tree.html">Tree</a></li>
<li><a href="../../../../../deprecated-list.html">Deprecated</a></li>
<li><a href="../../../../../index-all.html">Index</a></li>
<li><a href="../../../../../help-doc.html">Help</a></li>
</ul>
</div>
<div class="subNav">
<ul class="navList">
<li><a href="../../../../../edu/stanford/nlp/trees/tregex/TregexParseException.html" title="class in edu.stanford.nlp.trees.tregex"><span class="typeNameLink">Prev&nbsp;Class</span></a></li>
<li><a href="../../../../../edu/stanford/nlp/trees/tregex/TregexPattern.TRegexTreeReaderFactory.html" title="class in edu.stanford.nlp.trees.tregex"><span class="typeNameLink">Next&nbsp;Class</span></a></li>
</ul>
<ul class="navList">
<li><a href="../../../../../index.html?edu/stanford/nlp/trees/tregex/TregexPattern.html" target="_top">Frames</a></li>
<li><a href="TregexPattern.html" target="_top">No&nbsp;Frames</a></li>
</ul>
<ul class="navList" id="allclasses_navbar_top">
<li><a href="../../../../../allclasses-noframe.html">All&nbsp;Classes</a></li>
</ul>
<div>
<script type="text/javascript"><!--
  allClassesLink = document.getElementById("allclasses_navbar_top");
  if(window==top) {
    allClassesLink.style.display = "block";
  }
  else {
    allClassesLink.style.display = "none";
  }
  //-->
</script>
</div>
<div>
<ul class="subNavList">
<li>Summary:&nbsp;</li>
<li><a href="#nested.class.summary">Nested</a>&nbsp;|&nbsp;</li>
<li>Field&nbsp;|&nbsp;</li>
<li>Constr&nbsp;|&nbsp;</li>
<li><a href="#method.summary">Method</a></li>
</ul>
<ul class="subNavList">
<li>Detail:&nbsp;</li>
<li>Field&nbsp;|&nbsp;</li>
<li>Constr&nbsp;|&nbsp;</li>
<li><a href="#method.detail">Method</a></li>
</ul>
</div>
<a name="skip.navbar.top">
<!--   -->
</a></div>
<!-- ========= END OF TOP NAVBAR ========= -->
<!-- ======== START OF CLASS DATA ======== -->
<div class="header">
<div class="subTitle">edu.stanford.nlp.trees.tregex</div>
<h2 title="Class TregexPattern" class="title">Class TregexPattern</h2>
</div>
<div class="contentContainer">
<ul class="inheritance">
<li>java.lang.Object</li>
<li>
<ul class="inheritance">
<li>edu.stanford.nlp.trees.tregex.TregexPattern</li>
</ul>
</li>
</ul>
<div class="description">
<ul class="blockList">
<li class="blockList">
<dl>
<dt>All Implemented Interfaces:</dt>
<dd>java.io.Serializable</dd>
</dl>
<hr>
<br>
<pre>public abstract class <span class="typeNameLabel">TregexPattern</span>
extends java.lang.Object
implements java.io.Serializable</pre>
<div class="block">A TregexPattern is a <code>tgrep</code>-type pattern for matching tree
 node configurations.  Unlike <code>tgrep</code> or <code>tgrep2</code>but like Unix
 <code>grep</code>, there is no pre-indexing of the data to be searched.
 Rather there is a linear scan through the trees where matches are sought.
 As a result, matching is slower, but a TregexPattern can be applied
 to an arbitrary set of trees at runtime in a processing pipeline.

 <p> TregexPattern instances can be matched against instances of the <a href="../../../../../edu/stanford/nlp/trees/Tree.html" title="class in edu.stanford.nlp.trees"><code>Tree</code></a> class.
 The <a href="../../../../../edu/stanford/nlp/trees/tregex/TregexPattern.html#main-java.lang.String:A-"><code>main(java.lang.String[])</code></a> method can be used to find matching nodes of a treebank from the command line.

 <p>
 Currently supported node-node relations and their symbols:
 <p>
 <table border = "1">
 <tr><th>Symbol<th>Meaning
 <tr><td>A &lt;&lt; B <td>A dominates B
 <tr><td>A &gt;&gt; B <td>A is dominated by B
 <tr><td>A &lt; B <td>A immediately dominates B
 <tr><td>A &gt; B <td>A is immediately dominated by B
 <tr><td>A &#36; B <td>A is a sister of B (and not equal to B)
 <tr><td>A .. B <td>A precedes B
 <tr><td>A . B <td>A immediately precedes B
 <tr><td>A ,, B <td>A follows B
 <tr><td>A , B <td>A immediately follows B
 <tr><td>A &lt;&lt;, B <td>B is a leftmost descendant of A
 <tr><td>A &lt;&lt;- B <td>B is a rightmost descendant of A
 <tr><td>A &gt;&gt;, B <td>A is a leftmost descendant of B
 <tr><td>A &gt;&gt;- B <td>A is a rightmost descendant of B
 <tr><td>A &lt;, B <td>B is the first child of A
 <tr><td>A &gt;, B <td>A is the first child of B
 <tr><td>A &lt;- B <td>B is the last child of A
 <tr><td>A &gt;- B <td>A is the last child of B
 <tr><td>A &lt;` B <td>B is the last child of A
 <tr><td>A &gt;` B <td>A is the last child of B
 <tr><td>A &lt;i B <td>B is the ith child of A (i > 0)
 <tr><td>A &gt;i B <td>A is the ith child of B (i > 0)
 <tr><td>A &lt;-i B <td>B is the ith-to-last child of A (i > 0)
 <tr><td>A &gt;-i B <td>A is the ith-to-last child of B (i > 0)
 <tr><td>A &lt;: B <td>B is the only child of A
 <tr><td>A &gt;: B <td>A is the only child of B
 <tr><td>A &lt;&lt;: B <td>A dominates B via an unbroken chain (length > 0) of unary local trees.
 <tr><td>A &gt;&gt;: B <td>A is dominated by B via an unbroken chain (length > 0) of unary local trees.
 <tr><td>A &#36;++ B <td>A is a left sister of B (same as &#36;.. for context-free trees)
 <tr><td>A &#36;-- B <td>A is a right sister of B (same as &#36;,, for context-free trees)
 <tr><td>A &#36;+ B <td>A is the immediate left sister of B (same as &#36;. for context-free trees)
 <tr><td>A &#36;- B <td>A is the immediate right sister of B (same as &#36;, for context-free trees)
 <tr><td>A &#36;.. B <td>A is a sister of B and precedes B
 <tr><td>A &#36;,, B <td>A is a sister of B and follows B
 <tr><td>A &#36;. B <td>A is a sister of B and immediately precedes B
 <tr><td>A &#36;, B <td>A is a sister of B and immediately follows B
 <tr><td>A &lt;+(C) B <td>A dominates B via an unbroken chain of (zero or more) nodes matching description C
 <tr><td>A &gt;+(C) B <td>A is dominated by B via an unbroken chain of (zero or more) nodes matching description C
 <tr><td>A .+(C) B <td>A precedes B via an unbroken chain of (zero or more) nodes matching description C
 <tr><td>A ,+(C) B <td>A follows B via an unbroken chain of (zero or more) nodes matching description C
 <tr><td>A &lt;&lt;&#35; B <td>B is a head of phrase A
 <tr><td>A &gt;&gt;&#35; B <td>A is a head of phrase B
 <tr><td>A &lt;&#35; B <td>B is the immediate head of phrase A
 <tr><td>A &gt;&#35; B <td>A is the immediate head of phrase B
 <tr><td>A == B <td>A and B are the same node
 <tr><td>A &lt;= B <td>A and B are the same node or A is the parent of B
 <tr><td>A : B<td>[this is a pattern-segmenting operator that places no constraints on the relationship between A and B]
 <tr><td>A &lt;... { B ; C ; ... }<td>A has exactly B, C, etc as its subtree, with no other children.
 </table>
 <p> Label descriptions can be literal strings, which much match labels
 exactly, or regular expressions in regular expression bars: /regex/.
 Literal string matching proceeds as String equality.
 In order to prevent ambiguity with other Tregex symbols, ASCII symbols are
 not allowed in literal strings, and they cannot begin with ASCII digits.
 (That is literals can be standard "identifiers" matching
 [a-zA-Z]([a-zA-Z0-9_-])* but also may include letters from other alphabets.)
 If you want to use other symbols, you can do so by using a regular
 expression instead of a literal string.
 A disjunctive list of literal strings can be given separated by '|'.
 The special string '__' (two underscores) can be used to match any
 node.  (WARNING!!  Use of the '__' node description may seriously
 slow down search.)  If a label description is preceded by '@', the
 label will match any node whose <em>basicCategory</em> matches the
 description.  <emph>NB: A single '@' thus scopes over a disjunction
 specified by '|': @NP|VP means things with basic category NP or VP.
 </emph> The basicCategory is defined according to a Function
 mapping Strings to Strings, as provided by
 <a href="../../../../../edu/stanford/nlp/trees/AbstractTreebankLanguagePack.html#getBasicCategoryFunction--"><code>AbstractTreebankLanguagePack.getBasicCategoryFunction()</code></a>.
 Label description regular expressions are matched as <code>find()</code>,
 as in Perl/tgrep;
 you need to use <code>^</code> or <code>$</code> to constrain matches to
 the ends of strings.
 <p/>
 In a chain of relations, all relations are relative to the first node in
 the chain. For example, <code> (S &lt; VP &lt; NP) </code> means
 "an S over a VP and also over an NP".
 If instead what you want is an S above a VP above an NP, you should write
 "<code>S &lt; (VP &lt; NP)</code>".
 <p> Nodes can be grouped using parentheses '(' and ')'
 as in <code> S &lt; (NP $++ VP) </code> to match an S
 over an NP, where the NP has a VP as a right sister.

 <h3>Notes on relations</h3>

 <p>
 Node <code>B</code> "follows" node <code>A</code> if <code>B</code>
 or one of its ancestors is a right sibling of <code>A</code> or one
 of its ancestors.  Node <code>B</code> "immediately follows" node
 <code>A</code> if <code>B</code> follows <code>A</code> and there
 is no node <code>C</code> such that <code>B</code> follows
 <code>C</code> and <code>C</code> follows <code>A</code>.

 <p>
 Node <code>A</code> dominates <code>B</code> through an unbroken
 chain of unary local trees only if <code>A</code> is also
 unary. <code>(A (B))</code> is a valid example that matches <code>A
 &lt;&lt;: B</code>

 <p>
 When specifying that nodes are dominated via an unbroken chain of
 nodes matching a description <code>C</code>, the description
 <code>C</code> cannot be a full Tregex expression, but only an
 expression specifying the name of the node.  Negation of this
 description is allowed.

 <p>
 == has the same precedence as the other relations, so the expression
 <code>A &lt;&lt; B == A &lt;&lt; C</code> associates as
 <code>(((A &lt;&lt; B) == A) &lt;&lt; C)</code>, not as
 <code>((A &lt;&lt; B) == (A &lt;&lt; C))</code>.  (Both expressions are
 equivalent, of course, but this is just an example.)

 <h3>Boolean relational operators</h3>

 <p> Relations can be combined using the '&' and '|' operators,
 negated with the '!' operator, and made optional with the '?' operator.
 Thus <code> (NP < NN | < NNS) </code> will match an NP node dominating either
 an NN or an NNS.  <code> (NP > S & $++ VP) </code> matches an NP that
 is both under an S and has a VP as a right sister.
 <p>
 Expressions stop evaluating as soon as the result is known.  For
 example, if the pattern is <code>NP=a | NNP=b</code> and the NP
 matches, then variable <code>b</code> will not be assigned even if
 there is an NNP in the tree.

 <p> Relations can be grouped using brackets '[' and ']'.  So the
 expression

 <blockquote>
 <code> NP [< NN | < NNS] & > S </code>
 </blockquote>

  matches an NP that (1) dominates either an NN or an NNS, and (2) is under an S.  Without
 brackets, &amp; takes precedence over |, and equivalent operators are
 left-associative.  Also note that &amp; is the default combining operator if the
 operator is omitted in a chain of relations, so that the two patterns are equivalent:

 <blockquote>
 <code> (S < VP < NP) </code><br>
 <code> (S < VP & < NP) </code>
 </blockquote>

 As another example, <code> (VP < VV | < NP % NP)
 </code> can be written explicitly as <code> (VP [< VV | [< NP & % NP] ] )
 </code>

 <p> Relations can be negated with the '!' operator, in which case the
 expression will match only if there is no node satisfying the relation.
 For example <code> (NP !< NNP) </code> matches only NPs not dominating
 an NNP.  Label descriptions can also be negated with '!': (NP < !NNP|NNS) matches
 NPs dominating some node that is not an NNP or an NNS.

 <p> Relations can be made optional with the '?' operator.  This way the
 expression will match even if the optional relation is not satisfied.  This is useful when used together
  with node naming (see below).

 <p><h3>Basic Categories</h3>

 <p> In order to consider only the "basic category" of a tree label,
 i.e. to ignore functional tags or other annotations on the label,
 prefix that node's description with the &#64; symbol.  For example
 <code> (@NP < @/NN.?/) </code>  This can only be used for individual nodes;
 if you want all nodes to use the basic category, it would be more efficient
 to use a <a href="../../../../../edu/stanford/nlp/trees/TreeNormalizer.html" title="class in edu.stanford.nlp.trees"><code>TreeNormalizer</code></a> to remove functional
 tags before passing the tree to the TregexPattern.

 <p><h3>Segmenting patterns</h3>

 <p>The ":" operator allows you to segment a pattern into two pieces.  This can simplify your pattern writing.  For example,
 the pattern

 <blockquote>
   S : NP
 </blockquote>

 matches only those S nodes in trees that also have an NP node.

 <p><h3>Naming nodes</h3>

 <p> Nodes can be given names (a.k.a. handles) using '='.  A named node will be stored in a
 map that maps names to nodes so that if a match is found, the node
 corresponding to the named node can be extracted from the map.  For
 example <code> (NP < NNP=name) </code> will match an NP dominating an NNP
 and after a match is found, the map can be queried with the
 name to retreived the matched node using <a href="../../../../../edu/stanford/nlp/trees/tregex/TregexMatcher.html#getNode-java.lang.String-"><code>TregexMatcher.getNode(String o)</code></a>
 with (String) argument "name" (<it>not</it> "=name").
 Note that you are not allowed to name a node that is under the scope of a negation operator (the semantics would
 be unclear, since you can't store a node that never gets matched to).
 Trying to do so will cause a <a href="../../../../../edu/stanford/nlp/trees/tregex/TregexParseException.html" title="class in edu.stanford.nlp.trees.tregex"><code>TregexParseException</code></a> to be thrown. Named nodes <it>can be put within the scope of an optionality operator</it>.

 <p> Named nodes that refer back to previous named nodes need not have a node
 description -- this is known as "backreferencing".  In this case, the expression
 will match only when all instances of the same name get matched to the same tree node.
 For example: the pattern

 <blockquote>
 <code> (@NP <, (@NP $+ (/,/ $+ (@NP $+ /,/=comma))) <- =comma) </code>
 </blockquote>

 matches only an NP dominating exactly the four node sequence
 <code>NP , NP ,</code> -- the mother NP cannot have any other
 daughters. Multiple backreferences are allowed.  If the node w/ no
 node description does not refer to a previously named node, there
 will be no error, the expression simply will not match anything.

 <p> Another way to refer to previously named nodes is with the "link" symbol: '~'.
 A link is like a backreference, except that instead of having to be <i>equal to</i> the
 referred node, the current node only has to match the label of the referred to node.
 A link cannot have a node description, i.e. the '~' symbol must immediately follow a
 relation symbol.

 <p><h3>Customizing headship and basic categories</h3>

 <p> The HeadFinder used to determine heads for the head relations <code>&lt;#</code>, <code>&gt;#</code>, <code>&lt;&lt;#</code>, and <code>&gt;&gt;#</code>, and also
 the Function mapping from labels to Basic Category tags can be
 chosen by using a <a href="../../../../../edu/stanford/nlp/trees/tregex/TregexPatternCompiler.html" title="class in edu.stanford.nlp.trees.tregex"><code>TregexPatternCompiler</code></a>.

 <p><h3>Variable Groups</h3>

 <p> If you write a node description using a regular expression, you can assign its matching groups to variable names.
 If more than one node has a group assigned to the same variable name, then matching will only occur when all such groups
 capture the same string.  This is useful for enforcing coindexation constraints.  The syntax is

 <blockquote>
 <code> / &lt;regex-stuff&gt; /#&lt;group-number&gt;%&lt;variable-name&gt;</code>
 </blockquote>

 For example, the pattern (designed for Penn Treebank trees)

 <blockquote>
 <code> @SBAR < /^WH.*-([0-9]+)$/#1%index << (__=empty < (/^-NONE-/ < /^\*T\*-([0-9]+)$/#1%index)) </code>
 </blockquote>

 will match only such that the WH- node under the SBAR is coindexed with the trace node that gets the name <code>empty</code>.

 <p><h3>Getting Started</h3>

 Suppose we want to find all examples of subtrees where the label of
 the root of the subtree starts with MW.  For example, we want any
 subtree whose root is labeled MWV, MWN, etc.
 <br>
 The first thing to do is figure out what pattern to use.  Since we
 want to match anything starting with MW, we use the pattern
 <code>/^MW/</code>.
 <br>
 We then create a pattern, find matches in a given tree, and process
 those matches as follows:
 <blockquote>
 <code>
   // Create a reusable pattern object <br>
   TregexPattern patternMW = TregexPattern.compile("/^MW/"); <br>
   // Run the pattern on one particular tree <br>
   TregexMatcher matcher = patternMW.matcher(tree); <br>
   // Iterate over all of the subtrees that matched <br>
   while (matcher.findNextMatchingNode()) { <br>
   &nbsp;&nbsp;Tree match = matcher.getMatch(); <br>
   &nbsp;&nbsp;// do what we want to with the subtree <br>
   }
 </code>
 </blockquote>

 <p><h3>Current known bugs/shortcomings:</h3>

 <ul>

 <li> Tregex does not support disjunctions at the root level.  For
 example, the pattern <code>A | B</code> will not work.

 <li> Using multiple variable strings in one regex may not
 necessarily work.  For example, suppose the first two regex
 patterns are <code>/(.*)/#1%foo</code> and
 <code>/(.*)/#1%bar</code>.  You might then want to write a pattern
 that matches the concatenation of these patterns,
 <code>/(.*)(.*)/#1%foo#2%bar</code>, but that will not work.

 </ul></div>
<dl>
<dt><span class="simpleTagLabel">Author:</span></dt>
<dd>Galen Andrew, Roger Levy (rog@csli.stanford.edu), Anna Rafferty (filter mode), John Bauer (extensively tested and bugfixed)</dd>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="../../../../../serialized-form.html#edu.stanford.nlp.trees.tregex.TregexPattern">Serialized Form</a></dd>
</dl>
</li>
</ul>
</div>
<div class="summary">
<ul class="blockList">
<li class="blockList">
<!-- ======== NESTED CLASS SUMMARY ======== -->
<ul class="blockList">
<li class="blockList"><a name="nested.class.summary">
<!--   -->
</a>
<h3>Nested Class Summary</h3>
<table class="memberSummary" border="0" cellpadding="3" cellspacing="0" summary="Nested Class Summary table, listing nested classes, and an explanation">
<caption><span>Nested Classes</span><span class="tabEnd">&nbsp;</span></caption>
<tr>
<th class="colFirst" scope="col">Modifier and Type</th>
<th class="colLast" scope="col">Class and Description</th>
</tr>
<tr class="altColor">
<td class="colFirst"><code>static class&nbsp;</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../../../edu/stanford/nlp/trees/tregex/TregexPattern.TRegexTreeReaderFactory.html" title="class in edu.stanford.nlp.trees.tregex">TregexPattern.TRegexTreeReaderFactory</a></span></code>&nbsp;</td>
</tr>
</table>
</li>
</ul>
<!-- ========== METHOD SUMMARY =========== -->
<ul class="blockList">
<li class="blockList"><a name="method.summary">
<!--   -->
</a>
<h3>Method Summary</h3>
<table class="memberSummary" border="0" cellpadding="3" cellspacing="0" summary="Method Summary table, listing methods, and an explanation">
<caption><span id="t0" class="activeTableTab"><span>All Methods</span><span class="tabEnd">&nbsp;</span></span><span id="t1" class="tableTab"><span><a href="javascript:show(1);">Static Methods</a></span><span class="tabEnd">&nbsp;</span></span><span id="t2" class="tableTab"><span><a href="javascript:show(2);">Instance Methods</a></span><span class="tabEnd">&nbsp;</span></span><span id="t3" class="tableTab"><span><a href="javascript:show(4);">Abstract Methods</a></span><span class="tabEnd">&nbsp;</span></span><span id="t4" class="tableTab"><span><a href="javascript:show(8);">Concrete Methods</a></span><span class="tabEnd">&nbsp;</span></span></caption>
<tr>
<th class="colFirst" scope="col">Modifier and Type</th>
<th class="colLast" scope="col">Method and Description</th>
</tr>
<tr id="i0" class="altColor">
<td class="colFirst"><code>static <a href="../../../../../edu/stanford/nlp/trees/tregex/TregexPattern.html" title="class in edu.stanford.nlp.trees.tregex">TregexPattern</a></code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../../../edu/stanford/nlp/trees/tregex/TregexPattern.html#compile-java.lang.String-">compile</a></span>(java.lang.String&nbsp;tregex)</code>
<div class="block">Creates a pattern from the given string using the default HeadFinder and
 BasicCategoryFunction.</div>
</td>
</tr>
<tr id="i1" class="rowColor">
<td class="colFirst"><code>static void</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../../../edu/stanford/nlp/trees/tregex/TregexPattern.html#main-java.lang.String:A-">main</a></span>(java.lang.String[]&nbsp;args)</code>
<div class="block">Prints out all matches of a tree pattern on each tree in the path.</div>
</td>
</tr>
<tr id="i2" class="altColor">
<td class="colFirst"><code><a href="../../../../../edu/stanford/nlp/trees/tregex/TregexMatcher.html" title="class in edu.stanford.nlp.trees.tregex">TregexMatcher</a></code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../../../edu/stanford/nlp/trees/tregex/TregexPattern.html#matcher-edu.stanford.nlp.trees.Tree-">matcher</a></span>(<a href="../../../../../edu/stanford/nlp/trees/Tree.html" title="class in edu.stanford.nlp.trees">Tree</a>&nbsp;t)</code>
<div class="block">Get a <a href="../../../../../edu/stanford/nlp/trees/tregex/TregexMatcher.html" title="class in edu.stanford.nlp.trees.tregex"><code>TregexMatcher</code></a> for this pattern on this tree.</div>
</td>
</tr>
<tr id="i3" class="rowColor">
<td class="colFirst"><code><a href="../../../../../edu/stanford/nlp/trees/tregex/TregexMatcher.html" title="class in edu.stanford.nlp.trees.tregex">TregexMatcher</a></code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../../../edu/stanford/nlp/trees/tregex/TregexPattern.html#matcher-edu.stanford.nlp.trees.Tree-edu.stanford.nlp.trees.HeadFinder-">matcher</a></span>(<a href="../../../../../edu/stanford/nlp/trees/Tree.html" title="class in edu.stanford.nlp.trees">Tree</a>&nbsp;t,
       <a href="../../../../../edu/stanford/nlp/trees/HeadFinder.html" title="interface in edu.stanford.nlp.trees">HeadFinder</a>&nbsp;headFinder)</code>
<div class="block">Get a <a href="../../../../../edu/stanford/nlp/trees/tregex/TregexMatcher.html" title="class in edu.stanford.nlp.trees.tregex"><code>TregexMatcher</code></a> for this pattern on this tree.</div>
</td>
</tr>
<tr id="i4" class="altColor">
<td class="colFirst"><code>java.lang.String</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../../../edu/stanford/nlp/trees/tregex/TregexPattern.html#pattern--">pattern</a></span>()</code>&nbsp;</td>
</tr>
<tr id="i5" class="rowColor">
<td class="colFirst"><code>void</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../../../edu/stanford/nlp/trees/tregex/TregexPattern.html#prettyPrint--">prettyPrint</a></span>()</code>
<div class="block">Print a multi-line representation of the pattern illustrating
 it's syntax to System.out.</div>
</td>
</tr>
<tr id="i6" class="altColor">
<td class="colFirst"><code>void</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../../../edu/stanford/nlp/trees/tregex/TregexPattern.html#prettyPrint-java.io.PrintStream-">prettyPrint</a></span>(java.io.PrintStream&nbsp;ps)</code>
<div class="block">Print a multi-line representation
 of the pattern illustrating it's syntax.</div>
</td>
</tr>
<tr id="i7" class="rowColor">
<td class="colFirst"><code>void</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../../../edu/stanford/nlp/trees/tregex/TregexPattern.html#prettyPrint-java.io.PrintWriter-">prettyPrint</a></span>(java.io.PrintWriter&nbsp;pw)</code>
<div class="block">Print a multi-line representation
 of the pattern illustrating it's syntax.</div>
</td>
</tr>
<tr id="i8" class="altColor">
<td class="colFirst"><code>static <a href="../../../../../edu/stanford/nlp/trees/tregex/TregexPattern.html" title="class in edu.stanford.nlp.trees.tregex">TregexPattern</a></code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../../../edu/stanford/nlp/trees/tregex/TregexPattern.html#safeCompile-java.lang.String-boolean-">safeCompile</a></span>(java.lang.String&nbsp;tregex,
           boolean&nbsp;verbose)</code>
<div class="block">Creates a pattern from the given string using the default HeadFinder and
 BasicCategoryFunction.</div>
</td>
</tr>
<tr id="i9" class="rowColor">
<td class="colFirst"><code>abstract java.lang.String</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../../../edu/stanford/nlp/trees/tregex/TregexPattern.html#toString--">toString</a></span>()</code>&nbsp;</td>
</tr>
</table>
<ul class="blockList">
<li class="blockList"><a name="methods.inherited.from.class.java.lang.Object">
<!--   -->
</a>
<h3>Methods inherited from class&nbsp;java.lang.Object</h3>
<code>clone, equals, finalize, getClass, hashCode, notify, notifyAll, wait, wait, wait</code></li>
</ul>
</li>
</ul>
</li>
</ul>
</div>
<div class="details">
<ul class="blockList">
<li class="blockList">
<!-- ============ METHOD DETAIL ========== -->
<ul class="blockList">
<li class="blockList"><a name="method.detail">
<!--   -->
</a>
<h3>Method Detail</h3>
<a name="matcher-edu.stanford.nlp.trees.Tree-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>matcher</h4>
<pre>public&nbsp;<a href="../../../../../edu/stanford/nlp/trees/tregex/TregexMatcher.html" title="class in edu.stanford.nlp.trees.tregex">TregexMatcher</a>&nbsp;matcher(<a href="../../../../../edu/stanford/nlp/trees/Tree.html" title="class in edu.stanford.nlp.trees">Tree</a>&nbsp;t)</pre>
<div class="block">Get a <a href="../../../../../edu/stanford/nlp/trees/tregex/TregexMatcher.html" title="class in edu.stanford.nlp.trees.tregex"><code>TregexMatcher</code></a> for this pattern on this tree.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>t</code> - a tree to match on</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>a TregexMatcher</dd>
</dl>
</li>
</ul>
<a name="matcher-edu.stanford.nlp.trees.Tree-edu.stanford.nlp.trees.HeadFinder-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>matcher</h4>
<pre>public&nbsp;<a href="../../../../../edu/stanford/nlp/trees/tregex/TregexMatcher.html" title="class in edu.stanford.nlp.trees.tregex">TregexMatcher</a>&nbsp;matcher(<a href="../../../../../edu/stanford/nlp/trees/Tree.html" title="class in edu.stanford.nlp.trees">Tree</a>&nbsp;t,
                             <a href="../../../../../edu/stanford/nlp/trees/HeadFinder.html" title="interface in edu.stanford.nlp.trees">HeadFinder</a>&nbsp;headFinder)</pre>
<div class="block">Get a <a href="../../../../../edu/stanford/nlp/trees/tregex/TregexMatcher.html" title="class in edu.stanford.nlp.trees.tregex"><code>TregexMatcher</code></a> for this pattern on this tree.  Any Relations which use heads of trees should use the provided HeadFinder.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>t</code> - a tree to match on</dd>
<dd><code>headFinder</code> - a HeadFinder to use when matching</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>a TregexMatcher</dd>
</dl>
</li>
</ul>
<a name="compile-java.lang.String-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>compile</h4>
<pre>public static&nbsp;<a href="../../../../../edu/stanford/nlp/trees/tregex/TregexPattern.html" title="class in edu.stanford.nlp.trees.tregex">TregexPattern</a>&nbsp;compile(java.lang.String&nbsp;tregex)</pre>
<div class="block">Creates a pattern from the given string using the default HeadFinder and
 BasicCategoryFunction.  If you want to use a different HeadFinder or
 BasicCategoryFunction, use a <a href="../../../../../edu/stanford/nlp/trees/tregex/TregexPatternCompiler.html" title="class in edu.stanford.nlp.trees.tregex"><code>TregexPatternCompiler</code></a> object.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>tregex</code> - the pattern string</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>a TregexPattern for the string.</dd>
<dt><span class="throwsLabel">Throws:</span></dt>
<dd><code><a href="../../../../../edu/stanford/nlp/trees/tregex/TregexParseException.html" title="class in edu.stanford.nlp.trees.tregex">TregexParseException</a></code> - if the string does not parse</dd>
</dl>
</li>
</ul>
<a name="safeCompile-java.lang.String-boolean-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>safeCompile</h4>
<pre>public static&nbsp;<a href="../../../../../edu/stanford/nlp/trees/tregex/TregexPattern.html" title="class in edu.stanford.nlp.trees.tregex">TregexPattern</a>&nbsp;safeCompile(java.lang.String&nbsp;tregex,
                                        boolean&nbsp;verbose)</pre>
<div class="block">Creates a pattern from the given string using the default HeadFinder and
 BasicCategoryFunction.  If you want to use a different HeadFinder or
 BasicCategoryFunction, use a <a href="../../../../../edu/stanford/nlp/trees/tregex/TregexPatternCompiler.html" title="class in edu.stanford.nlp.trees.tregex"><code>TregexPatternCompiler</code></a> object.
 Rather than throwing an exception when the string does not parse,
 simply returns null.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>tregex</code> - the pattern string</dd>
<dd><code>verbose</code> - whether to log errors when the string doesn't parse</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>a TregexPattern for the string, or null if the string does not parse.</dd>
</dl>
</li>
</ul>
<a name="pattern--">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>pattern</h4>
<pre>public&nbsp;java.lang.String&nbsp;pattern()</pre>
</li>
</ul>
<a name="toString--">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>toString</h4>
<pre>public abstract&nbsp;java.lang.String&nbsp;toString()</pre>
<dl>
<dt><span class="overrideSpecifyLabel">Overrides:</span></dt>
<dd><code>toString</code>&nbsp;in class&nbsp;<code>java.lang.Object</code></dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>A single-line string representation of the pattern</dd>
</dl>
</li>
</ul>
<a name="prettyPrint-java.io.PrintWriter-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>prettyPrint</h4>
<pre>public&nbsp;void&nbsp;prettyPrint(java.io.PrintWriter&nbsp;pw)</pre>
<div class="block">Print a multi-line representation
 of the pattern illustrating it's syntax.</div>
</li>
</ul>
<a name="prettyPrint-java.io.PrintStream-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>prettyPrint</h4>
<pre>public&nbsp;void&nbsp;prettyPrint(java.io.PrintStream&nbsp;ps)</pre>
<div class="block">Print a multi-line representation
 of the pattern illustrating it's syntax.</div>
</li>
</ul>
<a name="prettyPrint--">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>prettyPrint</h4>
<pre>public&nbsp;void&nbsp;prettyPrint()</pre>
<div class="block">Print a multi-line representation of the pattern illustrating
 it's syntax to System.out.</div>
</li>
</ul>
<a name="main-java.lang.String:A-">
<!--   -->
</a>
<ul class="blockListLast">
<li class="blockList">
<h4>main</h4>
<pre>public static&nbsp;void&nbsp;main(java.lang.String[]&nbsp;args)
                 throws java.io.IOException</pre>
<div class="block">Prints out all matches of a tree pattern on each tree in the path.
 Usage: <br><br><code>
 java edu.stanford.nlp.trees.tregex.TregexPattern [[-TCwfosnu] [-filter] [-h &lt;node-name&gt;]]* pattern
  filepath   </code>

 <p>
 Arguments:<br>
 <ul><li><code>pattern</code>: the tree
 pattern which optionally names some set of nodes (i.e., gives it the "handle") <code>=name</code> (for some arbitrary
 string "name")
 <li> <code>filepath</code>: the path to files with trees. If this is a directory, there will be recursive descent and the pattern will be run on all files beneath the specified directory.
 </ul><p>
 Options:<br>
 <li> <code>-C</code> suppresses printing of matches, so only the
 number of matches is printed.
 <li> <code>-w</code> causes the whole of a tree that matches to be printed.
 <li> <code>-f</code> causes the filename to be printed.
 <li> <code>-i &lt;filename&gt;</code> causes the pattern to be matched to be read from <code>&lt;filename&gt;</code> rather than the command line.  Don't specify a pattern when this option is used.
 <li> <code>-o</code> Specifies that each tree node can be reported only once as the root of a match (by default a node will
 be printed once for every <em>way</em> the pattern matches).
 <li> <code>-s</code> causes trees to be printed all on one line (by default they are pretty printed).
 <li> <code>-n</code> causes the number of the tree in which the match was found to be
 printed before every match.
 <li> <code>-u</code> causes only the label of each matching node to be printed, not complete subtrees.
 <li> <code>-t</code> causes only the yield (terminal words) of the selected node to be printed (or the yield of the whole tree, if the <code>-w</code> option is used).
 <li> <code>-encoding &lt;charset_encoding&gt;</code> option allows specification of character encoding of trees..
 <li> <code>-h &lt;node-handle&gt;</code> If a <code>-h</code> option is given, the root tree node will not be printed.  Instead,
 for each <code>node-handle</code> specified, the node matched and given that handle will be printed.  Multiple nodes can be printed by using the
 <code>-h</code> option multiple times on a single command line.
 <li> <code>-hf &lt;headfinder-class-name&gt;</code> use the specified <a href="../../../../../edu/stanford/nlp/trees/HeadFinder.html" title="interface in edu.stanford.nlp.trees"><code>HeadFinder</code></a> class to determine headship relations.
 <li> <code>-hfArg &lt;string&gt;</code> pass a string argument in to the <a href="../../../../../edu/stanford/nlp/trees/HeadFinder.html" title="interface in edu.stanford.nlp.trees"><code>HeadFinder</code></a> class's constructor.  <code>-hfArg</code> can be used multiple times to pass in multiple arguments.
 <li> <code>-trf &lt;TreeReaderFactory-class-name&gt;</code> use the specified <a href="../../../../../edu/stanford/nlp/trees/TreeReaderFactory.html" title="interface in edu.stanford.nlp.trees"><code>TreeReaderFactory</code></a> class to read trees from files.
 <li> <code>-e &lt;extension&gt;</code> Only attempt to read files with the given extension. If not provided, will attempt to read all files.</li>
 <li> <code>-v</code> print every tree that contains no matches of the specified pattern, but print no matches to the pattern.

 <li> <code>-x</code> Instead of the matched subtree, print the matched subtree's identifying number as defined in <tt>tgrep2</tt>:a
 unique identifier for the subtree and is in the form s:n, where s is an integer specifying
 the sentence number in the corpus (starting with 1), and n is an integer giving the order
 in which the node is encountered in a depth-first search starting with 1 at top node in the
 sentence tree.

 <li> <code>-extract &lt;code&gt; &lt;tree-file&gt;</code> extracts the subtree s:n specified by <tt>code</tt> from the specified <tt>tree-file</tt>.  Overrides all other behavior of tregex.  Can't specify multiple encodings etc. yet.
 <li> <code>-extractFile &lt;code-file&gt; &lt;tree-file&gt;</code> extracts every subtree specified by the subtree codes in <tt>code-file</tt>, which must appear exactly one per line, from the specified <tt>tree-file</tt>.  Overrides all other behavior of tregex. Can't specify multiple encodings etc. yet.
 <li> <code>-filter</code> causes this to act as a filter, reading tree input from stdin
 <li> <code>-T</code> causes all trees to be printed as processed (for debugging purposes).  Otherwise only matching nodes are printed.
 <li> <code>-macros &lt;filename&gt;</code> filename with macro substitutions to use.  file with tab separated lines original-tab-replacement

 </ul></div>
<dl>
<dt><span class="throwsLabel">Throws:</span></dt>
<dd><code>java.io.IOException</code></dd>
</dl>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</div>
</div>
<!-- ========= END OF CLASS DATA ========= -->
<!-- ======= START OF BOTTOM NAVBAR ====== -->
<div class="bottomNav"><a name="navbar.bottom">
<!--   -->
</a>
<div class="skipNav"><a href="#skip.navbar.bottom" title="Skip navigation links">Skip navigation links</a></div>
<a name="navbar.bottom.firstrow">
<!--   -->
</a>
<ul class="navList" title="Navigation">
<li><a href="../../../../../overview-summary.html">Overview</a></li>
<li><a href="package-summary.html">Package</a></li>
<li class="navBarCell1Rev">Class</li>
<li><a href="package-tree.html">Tree</a></li>
<li><a href="../../../../../deprecated-list.html">Deprecated</a></li>
<li><a href="../../../../../index-all.html">Index</a></li>
<li><a href="../../../../../help-doc.html">Help</a></li>
</ul>
</div>
<div class="subNav">
<ul class="navList">
<li><a href="../../../../../edu/stanford/nlp/trees/tregex/TregexParseException.html" title="class in edu.stanford.nlp.trees.tregex"><span class="typeNameLink">Prev&nbsp;Class</span></a></li>
<li><a href="../../../../../edu/stanford/nlp/trees/tregex/TregexPattern.TRegexTreeReaderFactory.html" title="class in edu.stanford.nlp.trees.tregex"><span class="typeNameLink">Next&nbsp;Class</span></a></li>
</ul>
<ul class="navList">
<li><a href="../../../../../index.html?edu/stanford/nlp/trees/tregex/TregexPattern.html" target="_top">Frames</a></li>
<li><a href="TregexPattern.html" target="_top">No&nbsp;Frames</a></li>
</ul>
<ul class="navList" id="allclasses_navbar_bottom">
<li><a href="../../../../../allclasses-noframe.html">All&nbsp;Classes</a></li>
</ul>
<div>
<script type="text/javascript"><!--
  allClassesLink = document.getElementById("allclasses_navbar_bottom");
  if(window==top) {
    allClassesLink.style.display = "block";
  }
  else {
    allClassesLink.style.display = "none";
  }
  //-->
</script>
</div>
<div>
<ul class="subNavList">
<li>Summary:&nbsp;</li>
<li><a href="#nested.class.summary">Nested</a>&nbsp;|&nbsp;</li>
<li>Field&nbsp;|&nbsp;</li>
<li>Constr&nbsp;|&nbsp;</li>
<li><a href="#method.summary">Method</a></li>
</ul>
<ul class="subNavList">
<li>Detail:&nbsp;</li>
<li>Field&nbsp;|&nbsp;</li>
<li>Constr&nbsp;|&nbsp;</li>
<li><a href="#method.detail">Method</a></li>
</ul>
</div>
<a name="skip.navbar.bottom">
<!--   -->
</a></div>
<!-- ======== END OF BOTTOM NAVBAR ======= -->
<p class="legalCopy"><small><FONT SIZE=2><A HREF="http://nlp.stanford.edu">Stanford NLP Group</A></FONT></small></p>
</body>
</html>
