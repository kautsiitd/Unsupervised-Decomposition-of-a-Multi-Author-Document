<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<!-- NewPage -->
<html lang="en">
<head>
<!-- Generated by javadoc (1.8.0_65) on Wed Jan 20 02:13:44 PST 2016 -->
<title>Tree (Stanford JavaNLP API)</title>
<meta name="date" content="2016-01-20">
<link rel="stylesheet" type="text/css" href="../../../../stylesheet.css" title="Style">
<script type="text/javascript" src="../../../../script.js"></script>
</head>
<body>
<script type="text/javascript"><!--
    try {
        if (location.href.indexOf('is-external=true') == -1) {
            parent.document.title="Tree (Stanford JavaNLP API)";
        }
    }
    catch(err) {
    }
//-->
var methods = {"i0":10,"i1":10,"i2":10,"i3":10,"i4":6,"i5":10,"i6":10,"i7":10,"i8":10,"i9":10,"i10":10,"i11":10,"i12":10,"i13":10,"i14":10,"i15":10,"i16":10,"i17":10,"i18":10,"i19":10,"i20":10,"i21":10,"i22":10,"i23":10,"i24":10,"i25":10,"i26":10,"i27":10,"i28":10,"i29":10,"i30":10,"i31":10,"i32":10,"i33":10,"i34":10,"i35":10,"i36":10,"i37":10,"i38":10,"i39":10,"i40":10,"i41":10,"i42":10,"i43":10,"i44":10,"i45":10,"i46":10,"i47":10,"i48":10,"i49":10,"i50":10,"i51":10,"i52":10,"i53":10,"i54":10,"i55":10,"i56":10,"i57":10,"i58":10,"i59":10,"i60":10,"i61":10,"i62":10,"i63":10,"i64":10,"i65":10,"i66":10,"i67":10,"i68":10,"i69":10,"i70":10,"i71":10,"i72":10,"i73":10,"i74":10,"i75":10,"i76":10,"i77":10,"i78":10,"i79":10,"i80":10,"i81":10,"i82":10,"i83":10,"i84":10,"i85":10,"i86":10,"i87":10,"i88":10,"i89":10,"i90":10,"i91":10,"i92":10,"i93":10,"i94":10,"i95":10,"i96":10,"i97":10,"i98":10,"i99":10,"i100":10,"i101":10,"i102":10,"i103":10,"i104":10,"i105":10,"i106":10,"i107":10,"i108":10,"i109":10,"i110":10,"i111":10,"i112":10,"i113":10,"i114":10,"i115":6,"i116":10,"i117":10,"i118":10,"i119":10,"i120":10,"i121":10,"i122":9,"i123":9,"i124":10,"i125":10,"i126":10,"i127":10,"i128":10,"i129":10,"i130":10};
var tabs = {65535:["t0","All Methods"],1:["t1","Static Methods"],2:["t2","Instance Methods"],4:["t3","Abstract Methods"],8:["t4","Concrete Methods"]};
var altColor = "altColor";
var rowColor = "rowColor";
var tableTab = "tableTab";
var activeTableTab = "activeTableTab";
</script>
<noscript>
<div>JavaScript is disabled on your browser.</div>
</noscript>
<!-- ========= START OF TOP NAVBAR ======= -->
<div class="topNav"><a name="navbar.top">
<!--   -->
</a>
<div class="skipNav"><a href="#skip.navbar.top" title="Skip navigation links">Skip navigation links</a></div>
<a name="navbar.top.firstrow">
<!--   -->
</a>
<ul class="navList" title="Navigation">
<li><a href="../../../../overview-summary.html">Overview</a></li>
<li><a href="package-summary.html">Package</a></li>
<li class="navBarCell1Rev">Class</li>
<li><a href="package-tree.html">Tree</a></li>
<li><a href="../../../../deprecated-list.html">Deprecated</a></li>
<li><a href="../../../../index-all.html">Index</a></li>
<li><a href="../../../../help-doc.html">Help</a></li>
</ul>
</div>
<div class="subNav">
<ul class="navList">
<li><a href="../../../../edu/stanford/nlp/trees/TransformingTreebank.html" title="class in edu.stanford.nlp.trees"><span class="typeNameLink">Prev&nbsp;Class</span></a></li>
<li><a href="../../../../edu/stanford/nlp/trees/Treebank.html" title="class in edu.stanford.nlp.trees"><span class="typeNameLink">Next&nbsp;Class</span></a></li>
</ul>
<ul class="navList">
<li><a href="../../../../index.html?edu/stanford/nlp/trees/Tree.html" target="_top">Frames</a></li>
<li><a href="Tree.html" target="_top">No&nbsp;Frames</a></li>
</ul>
<ul class="navList" id="allclasses_navbar_top">
<li><a href="../../../../allclasses-noframe.html">All&nbsp;Classes</a></li>
</ul>
<div>
<script type="text/javascript"><!--
  allClassesLink = document.getElementById("allclasses_navbar_top");
  if(window==top) {
    allClassesLink.style.display = "block";
  }
  else {
    allClassesLink.style.display = "none";
  }
  //-->
</script>
</div>
<div>
<ul class="subNavList">
<li>Summary:&nbsp;</li>
<li>Nested&nbsp;|&nbsp;</li>
<li><a href="#field.summary">Field</a>&nbsp;|&nbsp;</li>
<li><a href="#constructor.summary">Constr</a>&nbsp;|&nbsp;</li>
<li><a href="#method.summary">Method</a></li>
</ul>
<ul class="subNavList">
<li>Detail:&nbsp;</li>
<li><a href="#field.detail">Field</a>&nbsp;|&nbsp;</li>
<li><a href="#constructor.detail">Constr</a>&nbsp;|&nbsp;</li>
<li><a href="#method.detail">Method</a></li>
</ul>
</div>
<a name="skip.navbar.top">
<!--   -->
</a></div>
<!-- ========= END OF TOP NAVBAR ========= -->
<!-- ======== START OF CLASS DATA ======== -->
<div class="header">
<div class="subTitle">edu.stanford.nlp.trees</div>
<h2 title="Class Tree" class="title">Class Tree</h2>
</div>
<div class="contentContainer">
<ul class="inheritance">
<li>java.lang.Object</li>
<li>
<ul class="inheritance">
<li>java.util.AbstractCollection&lt;<a href="../../../../edu/stanford/nlp/trees/Tree.html" title="class in edu.stanford.nlp.trees">Tree</a>&gt;</li>
<li>
<ul class="inheritance">
<li>edu.stanford.nlp.trees.Tree</li>
</ul>
</li>
</ul>
</li>
</ul>
<div class="description">
<ul class="blockList">
<li class="blockList">
<dl>
<dt>All Implemented Interfaces:</dt>
<dd><a href="../../../../edu/stanford/nlp/ling/Label.html" title="interface in edu.stanford.nlp.ling">Label</a>, <a href="../../../../edu/stanford/nlp/trees/Labeled.html" title="interface in edu.stanford.nlp.trees">Labeled</a>, <a href="../../../../edu/stanford/nlp/util/Scored.html" title="interface in edu.stanford.nlp.util">Scored</a>, java.io.Serializable, java.lang.Iterable&lt;<a href="../../../../edu/stanford/nlp/trees/Tree.html" title="class in edu.stanford.nlp.trees">Tree</a>&gt;, java.util.Collection&lt;<a href="../../../../edu/stanford/nlp/trees/Tree.html" title="class in edu.stanford.nlp.trees">Tree</a>&gt;</dd>
</dl>
<dl>
<dt>Direct Known Subclasses:</dt>
<dd><a href="../../../../edu/stanford/nlp/trees/LabeledScoredTreeNode.html" title="class in edu.stanford.nlp.trees">LabeledScoredTreeNode</a>, <a href="../../../../edu/stanford/nlp/trees/SimpleTree.html" title="class in edu.stanford.nlp.trees">SimpleTree</a>, <a href="../../../../edu/stanford/nlp/trees/TreeGraphNode.html" title="class in edu.stanford.nlp.trees">TreeGraphNode</a></dd>
</dl>
<hr>
<br>
<pre>public abstract class <span class="typeNameLabel">Tree</span>
extends java.util.AbstractCollection&lt;<a href="../../../../edu/stanford/nlp/trees/Tree.html" title="class in edu.stanford.nlp.trees">Tree</a>&gt;
implements <a href="../../../../edu/stanford/nlp/ling/Label.html" title="interface in edu.stanford.nlp.ling">Label</a>, <a href="../../../../edu/stanford/nlp/trees/Labeled.html" title="interface in edu.stanford.nlp.trees">Labeled</a>, <a href="../../../../edu/stanford/nlp/util/Scored.html" title="interface in edu.stanford.nlp.util">Scored</a>, java.io.Serializable</pre>
<div class="block">The abstract class <code>Tree</code> is used to collect all of the
 tree types, and acts as a generic extensible type.  This is the
 standard implementation of inheritance-based polymorphism.
 All <code>Tree</code> objects support accessors for their children (a
 <code>Tree[]</code>), their label (a <code>Label</code>), and their
 score (a <code>double</code>).  However, different concrete
 implementations may or may not include the latter two, in which
 case a default value is returned.  The class Tree defines no data
 fields.  The two abstract methods that must be implemented are:
 <code>children()</code>, and <code>treeFactory()</code>.  Notes
 that <code>setChildren(Tree[])</code> is now an optional
 operation, whereas it was previously required to be
 implemented. There is now support for finding the parent of a
 tree.  This may be done by search from a tree root, or via a
 directly stored parent.  The <code>Tree</code> class now
 implements the <code>Collection</code> interface: in terms of
 this, each <i>node</i> of the tree is an element of the
 collection; hence one can explore the tree by using the methods of
 this interface.  A <code>Tree</code> is regarded as a read-only
 <code>Collection</code> (even though the <code>Tree</code> class
 has various methods that modify trees).  Moreover, the
 implementation is <i>not</i> thread-safe: no attempt is made to
 detect and report concurrent modifications.</div>
<dl>
<dt><span class="simpleTagLabel">Author:</span></dt>
<dd>Christopher Manning, Dan Klein, Sarah Spikes (sdspikes@cs.stanford.edu) - filled in types</dd>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="../../../../serialized-form.html#edu.stanford.nlp.trees.Tree">Serialized Form</a></dd>
</dl>
</li>
</ul>
</div>
<div class="summary">
<ul class="blockList">
<li class="blockList">
<!-- =========== FIELD SUMMARY =========== -->
<ul class="blockList">
<li class="blockList"><a name="field.summary">
<!--   -->
</a>
<h3>Field Summary</h3>
<table class="memberSummary" border="0" cellpadding="3" cellspacing="0" summary="Field Summary table, listing fields, and an explanation">
<caption><span>Fields</span><span class="tabEnd">&nbsp;</span></caption>
<tr>
<th class="colFirst" scope="col">Modifier and Type</th>
<th class="colLast" scope="col">Field and Description</th>
</tr>
<tr class="altColor">
<td class="colFirst"><code>static <a href="../../../../edu/stanford/nlp/trees/Tree.html" title="class in edu.stanford.nlp.trees">Tree</a>[]</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../../edu/stanford/nlp/trees/Tree.html#EMPTY_TREE_ARRAY">EMPTY_TREE_ARRAY</a></span></code>
<div class="block">A leaf node should have a zero-length array for its
 children.</div>
</td>
</tr>
</table>
</li>
</ul>
<!-- ======== CONSTRUCTOR SUMMARY ======== -->
<ul class="blockList">
<li class="blockList"><a name="constructor.summary">
<!--   -->
</a>
<h3>Constructor Summary</h3>
<table class="memberSummary" border="0" cellpadding="3" cellspacing="0" summary="Constructor Summary table, listing constructors, and an explanation">
<caption><span>Constructors</span><span class="tabEnd">&nbsp;</span></caption>
<tr>
<th class="colOne" scope="col">Constructor and Description</th>
</tr>
<tr class="altColor">
<td class="colOne"><code><span class="memberNameLink"><a href="../../../../edu/stanford/nlp/trees/Tree.html#Tree--">Tree</a></span>()</code>&nbsp;</td>
</tr>
</table>
</li>
</ul>
<!-- ========== METHOD SUMMARY =========== -->
<ul class="blockList">
<li class="blockList"><a name="method.summary">
<!--   -->
</a>
<h3>Method Summary</h3>
<table class="memberSummary" border="0" cellpadding="3" cellspacing="0" summary="Method Summary table, listing methods, and an explanation">
<caption><span id="t0" class="activeTableTab"><span>All Methods</span><span class="tabEnd">&nbsp;</span></span><span id="t1" class="tableTab"><span><a href="javascript:show(1);">Static Methods</a></span><span class="tabEnd">&nbsp;</span></span><span id="t2" class="tableTab"><span><a href="javascript:show(2);">Instance Methods</a></span><span class="tabEnd">&nbsp;</span></span><span id="t3" class="tableTab"><span><a href="javascript:show(4);">Abstract Methods</a></span><span class="tabEnd">&nbsp;</span></span><span id="t4" class="tableTab"><span><a href="javascript:show(8);">Concrete Methods</a></span><span class="tabEnd">&nbsp;</span></span></caption>
<tr>
<th class="colFirst" scope="col">Modifier and Type</th>
<th class="colLast" scope="col">Method and Description</th>
</tr>
<tr id="i0" class="altColor">
<td class="colFirst"><code>void</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../../edu/stanford/nlp/trees/Tree.html#addChild-int-edu.stanford.nlp.trees.Tree-">addChild</a></span>(int&nbsp;i,
        <a href="../../../../edu/stanford/nlp/trees/Tree.html" title="class in edu.stanford.nlp.trees">Tree</a>&nbsp;t)</code>
<div class="block">Adds the tree t at the index position among the daughters.</div>
</td>
</tr>
<tr id="i1" class="rowColor">
<td class="colFirst"><code>void</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../../edu/stanford/nlp/trees/Tree.html#addChild-edu.stanford.nlp.trees.Tree-">addChild</a></span>(<a href="../../../../edu/stanford/nlp/trees/Tree.html" title="class in edu.stanford.nlp.trees">Tree</a>&nbsp;t)</code>
<div class="block">Adds the tree t at the last index position among the daughters.</div>
</td>
</tr>
<tr id="i2" class="altColor">
<td class="colFirst"><code><a href="../../../../edu/stanford/nlp/trees/Tree.html" title="class in edu.stanford.nlp.trees">Tree</a></code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../../edu/stanford/nlp/trees/Tree.html#ancestor-int-edu.stanford.nlp.trees.Tree-">ancestor</a></span>(int&nbsp;height,
        <a href="../../../../edu/stanford/nlp/trees/Tree.html" title="class in edu.stanford.nlp.trees">Tree</a>&nbsp;root)</code>
<div class="block">Return the ancestor tree node <code>height</code> nodes up from the current node.</div>
</td>
</tr>
<tr id="i3" class="rowColor">
<td class="colFirst"><code>boolean</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../../edu/stanford/nlp/trees/Tree.html#cCommands-edu.stanford.nlp.trees.Tree-edu.stanford.nlp.trees.Tree-">cCommands</a></span>(<a href="../../../../edu/stanford/nlp/trees/Tree.html" title="class in edu.stanford.nlp.trees">Tree</a>&nbsp;t1,
         <a href="../../../../edu/stanford/nlp/trees/Tree.html" title="class in edu.stanford.nlp.trees">Tree</a>&nbsp;t2)</code>
<div class="block">Given nodes <code>t1</code> and <code>t2</code> which are
 dominated by this node, returns <code>true</code> iff
 <code>t1</code> c-commands <code>t2</code>.</div>
</td>
</tr>
<tr id="i4" class="altColor">
<td class="colFirst"><code>abstract <a href="../../../../edu/stanford/nlp/trees/Tree.html" title="class in edu.stanford.nlp.trees">Tree</a>[]</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../../edu/stanford/nlp/trees/Tree.html#children--">children</a></span>()</code>
<div class="block">Returns an array of children for the current node.</div>
</td>
</tr>
<tr id="i5" class="rowColor">
<td class="colFirst"><code>java.util.Set&lt;<a href="../../../../edu/stanford/nlp/trees/Constituent.html" title="class in edu.stanford.nlp.trees">Constituent</a>&gt;</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../../edu/stanford/nlp/trees/Tree.html#constituents--">constituents</a></span>()</code>
<div class="block">Returns the Constituents generated by the parse tree.</div>
</td>
</tr>
<tr id="i6" class="altColor">
<td class="colFirst"><code>java.util.Set&lt;<a href="../../../../edu/stanford/nlp/trees/Constituent.html" title="class in edu.stanford.nlp.trees">Constituent</a>&gt;</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../../edu/stanford/nlp/trees/Tree.html#constituents-edu.stanford.nlp.trees.ConstituentFactory-">constituents</a></span>(<a href="../../../../edu/stanford/nlp/trees/ConstituentFactory.html" title="interface in edu.stanford.nlp.trees">ConstituentFactory</a>&nbsp;cf)</code>
<div class="block">Returns the Constituents generated by the parse tree.</div>
</td>
</tr>
<tr id="i7" class="rowColor">
<td class="colFirst"><code>java.util.Set&lt;<a href="../../../../edu/stanford/nlp/trees/Constituent.html" title="class in edu.stanford.nlp.trees">Constituent</a>&gt;</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../../edu/stanford/nlp/trees/Tree.html#constituents-edu.stanford.nlp.trees.ConstituentFactory-boolean-">constituents</a></span>(<a href="../../../../edu/stanford/nlp/trees/ConstituentFactory.html" title="interface in edu.stanford.nlp.trees">ConstituentFactory</a>&nbsp;cf,
            boolean&nbsp;charLevel)</code>
<div class="block">Returns the Constituents generated by the parse tree.</div>
</td>
</tr>
<tr id="i8" class="altColor">
<td class="colFirst"><code>java.util.Set&lt;<a href="../../../../edu/stanford/nlp/trees/Constituent.html" title="class in edu.stanford.nlp.trees">Constituent</a>&gt;</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../../edu/stanford/nlp/trees/Tree.html#constituents-edu.stanford.nlp.trees.ConstituentFactory-boolean-java.util.function.Predicate-">constituents</a></span>(<a href="../../../../edu/stanford/nlp/trees/ConstituentFactory.html" title="interface in edu.stanford.nlp.trees">ConstituentFactory</a>&nbsp;cf,
            boolean&nbsp;charLevel,
            java.util.function.Predicate&lt;<a href="../../../../edu/stanford/nlp/trees/Tree.html" title="class in edu.stanford.nlp.trees">Tree</a>&gt;&nbsp;filter)</code>&nbsp;</td>
</tr>
<tr id="i9" class="rowColor">
<td class="colFirst"><code>java.util.Set&lt;<a href="../../../../edu/stanford/nlp/trees/Constituent.html" title="class in edu.stanford.nlp.trees">Constituent</a>&gt;</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../../edu/stanford/nlp/trees/Tree.html#constituents-edu.stanford.nlp.trees.ConstituentFactory-int-">constituents</a></span>(<a href="../../../../edu/stanford/nlp/trees/ConstituentFactory.html" title="interface in edu.stanford.nlp.trees">ConstituentFactory</a>&nbsp;cf,
            int&nbsp;maxDepth)</code>
<div class="block">Returns the Constituents generated by the parse tree.</div>
</td>
</tr>
<tr id="i10" class="altColor">
<td class="colFirst"><code><a href="../../../../edu/stanford/nlp/trees/Tree.html" title="class in edu.stanford.nlp.trees">Tree</a></code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../../edu/stanford/nlp/trees/Tree.html#deepCopy--">deepCopy</a></span>()</code>
<div class="block">Makes a deep copy of not only the Tree structure but of the labels as well.</div>
</td>
</tr>
<tr id="i11" class="rowColor">
<td class="colFirst"><code><a href="../../../../edu/stanford/nlp/trees/Tree.html" title="class in edu.stanford.nlp.trees">Tree</a></code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../../edu/stanford/nlp/trees/Tree.html#deepCopy-edu.stanford.nlp.trees.TreeFactory-">deepCopy</a></span>(<a href="../../../../edu/stanford/nlp/trees/TreeFactory.html" title="interface in edu.stanford.nlp.trees">TreeFactory</a>&nbsp;tf)</code>
<div class="block">Makes a deep copy of not only the Tree structure but of the labels as well.</div>
</td>
</tr>
<tr id="i12" class="altColor">
<td class="colFirst"><code><a href="../../../../edu/stanford/nlp/trees/Tree.html" title="class in edu.stanford.nlp.trees">Tree</a></code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../../edu/stanford/nlp/trees/Tree.html#deepCopy-edu.stanford.nlp.trees.TreeFactory-edu.stanford.nlp.ling.LabelFactory-">deepCopy</a></span>(<a href="../../../../edu/stanford/nlp/trees/TreeFactory.html" title="interface in edu.stanford.nlp.trees">TreeFactory</a>&nbsp;tf,
        <a href="../../../../edu/stanford/nlp/ling/LabelFactory.html" title="interface in edu.stanford.nlp.ling">LabelFactory</a>&nbsp;lf)</code>
<div class="block">Makes a deep copy of not only the Tree structure but of the labels as well.</div>
</td>
</tr>
<tr id="i13" class="rowColor">
<td class="colFirst"><code>java.util.Set&lt;<a href="../../../../edu/stanford/nlp/trees/Dependency.html" title="interface in edu.stanford.nlp.trees">Dependency</a>&lt;<a href="../../../../edu/stanford/nlp/ling/Label.html" title="interface in edu.stanford.nlp.ling">Label</a>,<a href="../../../../edu/stanford/nlp/ling/Label.html" title="interface in edu.stanford.nlp.ling">Label</a>,java.lang.Object&gt;&gt;</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../../edu/stanford/nlp/trees/Tree.html#dependencies--">dependencies</a></span>()</code>
<div class="block">Return a Set of TaggedWord-TaggedWord dependencies, represented as
 Dependency objects, for the Tree.</div>
</td>
</tr>
<tr id="i14" class="altColor">
<td class="colFirst"><code>java.util.Set&lt;<a href="../../../../edu/stanford/nlp/trees/Dependency.html" title="interface in edu.stanford.nlp.trees">Dependency</a>&lt;<a href="../../../../edu/stanford/nlp/ling/Label.html" title="interface in edu.stanford.nlp.ling">Label</a>,<a href="../../../../edu/stanford/nlp/ling/Label.html" title="interface in edu.stanford.nlp.ling">Label</a>,java.lang.Object&gt;&gt;</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../../edu/stanford/nlp/trees/Tree.html#dependencies-java.util.function.Predicate-">dependencies</a></span>(java.util.function.Predicate&lt;<a href="../../../../edu/stanford/nlp/trees/Dependency.html" title="interface in edu.stanford.nlp.trees">Dependency</a>&lt;<a href="../../../../edu/stanford/nlp/ling/Label.html" title="interface in edu.stanford.nlp.ling">Label</a>,<a href="../../../../edu/stanford/nlp/ling/Label.html" title="interface in edu.stanford.nlp.ling">Label</a>,java.lang.Object&gt;&gt;&nbsp;f)</code>&nbsp;</td>
</tr>
<tr id="i15" class="rowColor">
<td class="colFirst"><code>java.util.Set&lt;<a href="../../../../edu/stanford/nlp/trees/Dependency.html" title="interface in edu.stanford.nlp.trees">Dependency</a>&lt;<a href="../../../../edu/stanford/nlp/ling/Label.html" title="interface in edu.stanford.nlp.ling">Label</a>,<a href="../../../../edu/stanford/nlp/ling/Label.html" title="interface in edu.stanford.nlp.ling">Label</a>,java.lang.Object&gt;&gt;</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../../edu/stanford/nlp/trees/Tree.html#dependencies-java.util.function.Predicate-boolean-boolean-boolean-">dependencies</a></span>(java.util.function.Predicate&lt;<a href="../../../../edu/stanford/nlp/trees/Dependency.html" title="interface in edu.stanford.nlp.trees">Dependency</a>&lt;<a href="../../../../edu/stanford/nlp/ling/Label.html" title="interface in edu.stanford.nlp.ling">Label</a>,<a href="../../../../edu/stanford/nlp/ling/Label.html" title="interface in edu.stanford.nlp.ling">Label</a>,java.lang.Object&gt;&gt;&nbsp;f,
            boolean&nbsp;isConcrete,
            boolean&nbsp;copyLabel,
            boolean&nbsp;copyPosTag)</code>
<div class="block">Return a set of TaggedWord-TaggedWord dependencies, represented as
 Dependency objects, for the Tree.</div>
</td>
</tr>
<tr id="i16" class="altColor">
<td class="colFirst"><code>int</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../../edu/stanford/nlp/trees/Tree.html#depth--">depth</a></span>()</code>
<div class="block">Finds the depth of the tree.</div>
</td>
</tr>
<tr id="i17" class="rowColor">
<td class="colFirst"><code>int</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../../edu/stanford/nlp/trees/Tree.html#depth-edu.stanford.nlp.trees.Tree-">depth</a></span>(<a href="../../../../edu/stanford/nlp/trees/Tree.html" title="class in edu.stanford.nlp.trees">Tree</a>&nbsp;node)</code>
<div class="block">Finds the distance from this node to the specified node.</div>
</td>
</tr>
<tr id="i18" class="altColor">
<td class="colFirst"><code>boolean</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../../edu/stanford/nlp/trees/Tree.html#dominates-edu.stanford.nlp.trees.Tree-">dominates</a></span>(<a href="../../../../edu/stanford/nlp/trees/Tree.html" title="class in edu.stanford.nlp.trees">Tree</a>&nbsp;t)</code>
<div class="block">Returns true if <code>this</code> dominates the Tree passed in
 as an argument.</div>
</td>
</tr>
<tr id="i19" class="rowColor">
<td class="colFirst"><code>java.util.List&lt;<a href="../../../../edu/stanford/nlp/trees/Tree.html" title="class in edu.stanford.nlp.trees">Tree</a>&gt;</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../../edu/stanford/nlp/trees/Tree.html#dominationPath-edu.stanford.nlp.trees.Tree-">dominationPath</a></span>(<a href="../../../../edu/stanford/nlp/trees/Tree.html" title="class in edu.stanford.nlp.trees">Tree</a>&nbsp;t)</code>
<div class="block">Returns the path of nodes leading down to a dominated node,
 including <code>this</code> and the dominated node itself.</div>
</td>
</tr>
<tr id="i20" class="altColor">
<td class="colFirst"><code>boolean</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../../edu/stanford/nlp/trees/Tree.html#equals-java.lang.Object-">equals</a></span>(java.lang.Object&nbsp;o)</code>
<div class="block">Implements equality for Tree's.</div>
</td>
</tr>
<tr id="i21" class="rowColor">
<td class="colFirst"><code><a href="../../../../edu/stanford/nlp/trees/Tree.html" title="class in edu.stanford.nlp.trees">Tree</a></code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../../edu/stanford/nlp/trees/Tree.html#firstChild--">firstChild</a></span>()</code>
<div class="block">Returns the first child of a tree, or <code>null</code> if none.</div>
</td>
</tr>
<tr id="i22" class="altColor">
<td class="colFirst"><code><a href="../../../../edu/stanford/nlp/trees/Tree.html" title="class in edu.stanford.nlp.trees">Tree</a></code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../../edu/stanford/nlp/trees/Tree.html#flatten--">flatten</a></span>()</code>
<div class="block">Return a flattened version of a tree.</div>
</td>
</tr>
<tr id="i23" class="rowColor">
<td class="colFirst"><code><a href="../../../../edu/stanford/nlp/trees/Tree.html" title="class in edu.stanford.nlp.trees">Tree</a></code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../../edu/stanford/nlp/trees/Tree.html#flatten-edu.stanford.nlp.trees.TreeFactory-">flatten</a></span>(<a href="../../../../edu/stanford/nlp/trees/TreeFactory.html" title="interface in edu.stanford.nlp.trees">TreeFactory</a>&nbsp;tf)</code>
<div class="block">Return a flattened version of a tree.</div>
</td>
</tr>
<tr id="i24" class="altColor">
<td class="colFirst"><code><a href="../../../../edu/stanford/nlp/trees/Tree.html" title="class in edu.stanford.nlp.trees">Tree</a></code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../../edu/stanford/nlp/trees/Tree.html#getChild-int-">getChild</a></span>(int&nbsp;i)</code>
<div class="block">Return the child at some daughter index.</div>
</td>
</tr>
<tr id="i25" class="rowColor">
<td class="colFirst"><code>java.util.List&lt;<a href="../../../../edu/stanford/nlp/trees/Tree.html" title="class in edu.stanford.nlp.trees">Tree</a>&gt;</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../../edu/stanford/nlp/trees/Tree.html#getChildrenAsList--">getChildrenAsList</a></span>()</code>
<div class="block">Returns a List of children for the current node.</div>
</td>
</tr>
<tr id="i26" class="altColor">
<td class="colFirst"><code>&lt;T extends <a href="../../../../edu/stanford/nlp/trees/Tree.html" title="class in edu.stanford.nlp.trees">Tree</a>&gt;<br>java.util.List&lt;T&gt;</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../../edu/stanford/nlp/trees/Tree.html#getLeaves--">getLeaves</a></span>()</code>
<div class="block">Gets the leaves of the tree.</div>
</td>
</tr>
<tr id="i27" class="rowColor">
<td class="colFirst"><code>&lt;T extends <a href="../../../../edu/stanford/nlp/trees/Tree.html" title="class in edu.stanford.nlp.trees">Tree</a>&gt;<br>java.util.List&lt;T&gt;</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../../edu/stanford/nlp/trees/Tree.html#getLeaves-java.util.List-">getLeaves</a></span>(java.util.List&lt;T&gt;&nbsp;list)</code>
<div class="block">Gets the leaves of the tree.</div>
</td>
</tr>
<tr id="i28" class="altColor">
<td class="colFirst"><code><a href="../../../../edu/stanford/nlp/trees/Tree.html" title="class in edu.stanford.nlp.trees">Tree</a></code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../../edu/stanford/nlp/trees/Tree.html#getNodeNumber-int-">getNodeNumber</a></span>(int&nbsp;i)</code>
<div class="block">Fetches the <code>i</code>th node in the tree, with node numbers defined
 as in <a href="../../../../edu/stanford/nlp/trees/Tree.html#nodeNumber-edu.stanford.nlp.trees.Tree-"><code>nodeNumber(Tree)</code></a>.</div>
</td>
</tr>
<tr id="i29" class="rowColor">
<td class="colFirst"><code><a href="../../../../edu/stanford/nlp/util/IntPair.html" title="class in edu.stanford.nlp.util">IntPair</a></code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../../edu/stanford/nlp/trees/Tree.html#getSpan--">getSpan</a></span>()</code>
<div class="block">Returns SpanAnnotation of this node, or null if annotation is not assigned.</div>
</td>
</tr>
<tr id="i30" class="altColor">
<td class="colFirst"><code>int</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../../edu/stanford/nlp/trees/Tree.html#hashCode--">hashCode</a></span>()</code>
<div class="block">Implements a hashCode for Tree's.</div>
</td>
</tr>
<tr id="i31" class="rowColor">
<td class="colFirst"><code><a href="../../../../edu/stanford/nlp/trees/Tree.html" title="class in edu.stanford.nlp.trees">Tree</a></code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../../edu/stanford/nlp/trees/Tree.html#headPreTerminal-edu.stanford.nlp.trees.HeadFinder-">headPreTerminal</a></span>(<a href="../../../../edu/stanford/nlp/trees/HeadFinder.html" title="interface in edu.stanford.nlp.trees">HeadFinder</a>&nbsp;hf)</code>
<div class="block">Returns the preterminal tree that is the head of the tree.</div>
</td>
</tr>
<tr id="i32" class="altColor">
<td class="colFirst"><code><a href="../../../../edu/stanford/nlp/trees/Tree.html" title="class in edu.stanford.nlp.trees">Tree</a></code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../../edu/stanford/nlp/trees/Tree.html#headTerminal-edu.stanford.nlp.trees.HeadFinder-">headTerminal</a></span>(<a href="../../../../edu/stanford/nlp/trees/HeadFinder.html" title="interface in edu.stanford.nlp.trees">HeadFinder</a>&nbsp;hf)</code>
<div class="block">Returns the tree leaf that is the head of the tree.</div>
</td>
</tr>
<tr id="i33" class="rowColor">
<td class="colFirst"><code><a href="../../../../edu/stanford/nlp/trees/Tree.html" title="class in edu.stanford.nlp.trees">Tree</a></code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../../edu/stanford/nlp/trees/Tree.html#headTerminal-edu.stanford.nlp.trees.HeadFinder-edu.stanford.nlp.trees.Tree-">headTerminal</a></span>(<a href="../../../../edu/stanford/nlp/trees/HeadFinder.html" title="interface in edu.stanford.nlp.trees">HeadFinder</a>&nbsp;hf,
            <a href="../../../../edu/stanford/nlp/trees/Tree.html" title="class in edu.stanford.nlp.trees">Tree</a>&nbsp;parent)</code>
<div class="block">Returns the tree leaf that is the head of the tree.</div>
</td>
</tr>
<tr id="i34" class="altColor">
<td class="colFirst"><code>void</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../../edu/stanford/nlp/trees/Tree.html#indentedListPrint--">indentedListPrint</a></span>()</code>
<div class="block">Indented list printing of a tree.</div>
</td>
</tr>
<tr id="i35" class="rowColor">
<td class="colFirst"><code>void</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../../edu/stanford/nlp/trees/Tree.html#indentedListPrint-java.io.PrintWriter-boolean-">indentedListPrint</a></span>(java.io.PrintWriter&nbsp;pw,
                 boolean&nbsp;printScores)</code>
<div class="block">Indented list printing of a tree.</div>
</td>
</tr>
<tr id="i36" class="altColor">
<td class="colFirst"><code>void</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../../edu/stanford/nlp/trees/Tree.html#indentedXMLPrint--">indentedXMLPrint</a></span>()</code>
<div class="block">Indented xml printing of a tree.</div>
</td>
</tr>
<tr id="i37" class="rowColor">
<td class="colFirst"><code>void</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../../edu/stanford/nlp/trees/Tree.html#indentedXMLPrint-java.io.PrintWriter-boolean-">indentedXMLPrint</a></span>(java.io.PrintWriter&nbsp;pw,
                boolean&nbsp;printScores)</code>
<div class="block">Indented xml printing of a tree.</div>
</td>
</tr>
<tr id="i38" class="altColor">
<td class="colFirst"><code>void</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../../edu/stanford/nlp/trees/Tree.html#indexLeaves--">indexLeaves</a></span>()</code>
<div class="block">Assign sequential integer indices to the leaves of the tree
 rooted at this <code>Tree</code>, starting with 1.</div>
</td>
</tr>
<tr id="i39" class="rowColor">
<td class="colFirst"><code>void</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../../edu/stanford/nlp/trees/Tree.html#indexLeaves-boolean-">indexLeaves</a></span>(boolean&nbsp;overWrite)</code>
<div class="block">Index the leaves, and optionally overwrite existing IndexAnnotations if they exist.</div>
</td>
</tr>
<tr id="i40" class="altColor">
<td class="colFirst"><code>int</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../../edu/stanford/nlp/trees/Tree.html#indexLeaves-int-boolean-">indexLeaves</a></span>(int&nbsp;startIndex,
           boolean&nbsp;overWrite)</code>
<div class="block">Assign sequential integer indices to the leaves of the subtree
 rooted at this <code>Tree</code>, beginning with
 <code>startIndex</code>, and traversing the leaves from left
 to right.</div>
</td>
</tr>
<tr id="i41" class="rowColor">
<td class="colFirst"><code>void</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../../edu/stanford/nlp/trees/Tree.html#indexSpans--">indexSpans</a></span>()</code>
<div class="block">Index all spans (constituents) in the tree.</div>
</td>
</tr>
<tr id="i42" class="altColor">
<td class="colFirst"><code>void</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../../edu/stanford/nlp/trees/Tree.html#indexSpans-int-">indexSpans</a></span>(int&nbsp;startIndex)</code>&nbsp;</td>
</tr>
<tr id="i43" class="rowColor">
<td class="colFirst"><code><a href="../../../../edu/stanford/nlp/util/Pair.html" title="class in edu.stanford.nlp.util">Pair</a>&lt;java.lang.Integer,java.lang.Integer&gt;</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../../edu/stanford/nlp/trees/Tree.html#indexSpans-edu.stanford.nlp.util.MutableInteger-">indexSpans</a></span>(<a href="../../../../edu/stanford/nlp/util/MutableInteger.html" title="class in edu.stanford.nlp.util">MutableInteger</a>&nbsp;startIndex)</code>
<div class="block">Assigns span indices (BeginIndexAnnotation and EndIndexAnnotation) to all nodes in a tree.</div>
</td>
</tr>
<tr id="i44" class="altColor">
<td class="colFirst"><code>void</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../../edu/stanford/nlp/trees/Tree.html#insertDtr-edu.stanford.nlp.trees.Tree-int-">insertDtr</a></span>(<a href="../../../../edu/stanford/nlp/trees/Tree.html" title="class in edu.stanford.nlp.trees">Tree</a>&nbsp;dtr,
         int&nbsp;position)</code>
<div class="block">insert <code>dtr</code> after <code>position</code> existing
 daughters in <code>this</code>.</div>
</td>
</tr>
<tr id="i45" class="rowColor">
<td class="colFirst"><code>boolean</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../../edu/stanford/nlp/trees/Tree.html#isLeaf--">isLeaf</a></span>()</code>
<div class="block">Says whether a node is a leaf.</div>
</td>
</tr>
<tr id="i46" class="altColor">
<td class="colFirst"><code>boolean</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../../edu/stanford/nlp/trees/Tree.html#isPhrasal--">isPhrasal</a></span>()</code>
<div class="block">Return whether this node is a phrasal node or not.</div>
</td>
</tr>
<tr id="i47" class="rowColor">
<td class="colFirst"><code>boolean</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../../edu/stanford/nlp/trees/Tree.html#isPrePreTerminal--">isPrePreTerminal</a></span>()</code>
<div class="block">Return whether all the children of this node are preterminals or not.</div>
</td>
</tr>
<tr id="i48" class="altColor">
<td class="colFirst"><code>boolean</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../../edu/stanford/nlp/trees/Tree.html#isPreTerminal--">isPreTerminal</a></span>()</code>
<div class="block">Return whether this node is a preterminal or not.</div>
</td>
</tr>
<tr id="i49" class="rowColor">
<td class="colFirst"><code>boolean</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../../edu/stanford/nlp/trees/Tree.html#isUnaryRewrite--">isUnaryRewrite</a></span>()</code>
<div class="block">Says whether the current node has only one child.</div>
</td>
</tr>
<tr id="i50" class="altColor">
<td class="colFirst"><code>java.util.Iterator&lt;<a href="../../../../edu/stanford/nlp/trees/Tree.html" title="class in edu.stanford.nlp.trees">Tree</a>&gt;</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../../edu/stanford/nlp/trees/Tree.html#iterator--">iterator</a></span>()</code>
<div class="block">Returns an iterator over all the nodes of the tree.</div>
</td>
</tr>
<tr id="i51" class="rowColor">
<td class="colFirst"><code><a href="../../../../edu/stanford/nlp/trees/Tree.html" title="class in edu.stanford.nlp.trees">Tree</a></code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../../edu/stanford/nlp/trees/Tree.html#joinNode-edu.stanford.nlp.trees.Tree-edu.stanford.nlp.trees.Tree-">joinNode</a></span>(<a href="../../../../edu/stanford/nlp/trees/Tree.html" title="class in edu.stanford.nlp.trees">Tree</a>&nbsp;t1,
        <a href="../../../../edu/stanford/nlp/trees/Tree.html" title="class in edu.stanford.nlp.trees">Tree</a>&nbsp;t2)</code>
<div class="block">Given nodes <code>t1</code> and <code>t2</code> which are
 dominated by this node, returns their "join node": the node
 <code>j</code> such that <code>j</code> dominates both
 <code>t1</code> and <code>t2</code>, and every other node which
 dominates both <code>t1</code> and <code>t2</code>
 dominates <code>j</code>.</div>
</td>
</tr>
<tr id="i52" class="altColor">
<td class="colFirst"><code><a href="../../../../edu/stanford/nlp/ling/Label.html" title="interface in edu.stanford.nlp.ling">Label</a></code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../../edu/stanford/nlp/trees/Tree.html#label--">label</a></span>()</code>
<div class="block">Returns the label associated with the current node, or null
 if there is no label.</div>
</td>
</tr>
<tr id="i53" class="rowColor">
<td class="colFirst"><code>java.util.List&lt;<a href="../../../../edu/stanford/nlp/ling/LabeledWord.html" title="class in edu.stanford.nlp.ling">LabeledWord</a>&gt;</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../../edu/stanford/nlp/trees/Tree.html#labeledYield--">labeledYield</a></span>()</code>&nbsp;</td>
</tr>
<tr id="i54" class="altColor">
<td class="colFirst"><code>java.util.List&lt;<a href="../../../../edu/stanford/nlp/ling/LabeledWord.html" title="class in edu.stanford.nlp.ling">LabeledWord</a>&gt;</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../../edu/stanford/nlp/trees/Tree.html#labeledYield-java.util.List-">labeledYield</a></span>(java.util.List&lt;<a href="../../../../edu/stanford/nlp/ling/LabeledWord.html" title="class in edu.stanford.nlp.ling">LabeledWord</a>&gt;&nbsp;ty)</code>&nbsp;</td>
</tr>
<tr id="i55" class="rowColor">
<td class="colFirst"><code><a href="../../../../edu/stanford/nlp/ling/LabelFactory.html" title="interface in edu.stanford.nlp.ling">LabelFactory</a></code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../../edu/stanford/nlp/trees/Tree.html#labelFactory--">labelFactory</a></span>()</code>
<div class="block">Returns a factory that makes labels of the same type as this one.</div>
</td>
</tr>
<tr id="i56" class="altColor">
<td class="colFirst"><code>java.util.Collection&lt;<a href="../../../../edu/stanford/nlp/ling/Label.html" title="interface in edu.stanford.nlp.ling">Label</a>&gt;</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../../edu/stanford/nlp/trees/Tree.html#labels--">labels</a></span>()</code>
<div class="block">Get the set of all node and leaf <code>Label</code>s,
 null or otherwise, contained in the tree.</div>
</td>
</tr>
<tr id="i57" class="rowColor">
<td class="colFirst"><code><a href="../../../../edu/stanford/nlp/trees/Tree.html" title="class in edu.stanford.nlp.trees">Tree</a></code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../../edu/stanford/nlp/trees/Tree.html#lastChild--">lastChild</a></span>()</code>
<div class="block">Returns the last child of a tree, or <code>null</code> if none.</div>
</td>
</tr>
<tr id="i58" class="altColor">
<td class="colFirst"><code>int</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../../edu/stanford/nlp/trees/Tree.html#leftCharEdge-edu.stanford.nlp.trees.Tree-">leftCharEdge</a></span>(<a href="../../../../edu/stanford/nlp/trees/Tree.html" title="class in edu.stanford.nlp.trees">Tree</a>&nbsp;node)</code>
<div class="block">Returns the positional index of the left edge of  <i>node</i> within the tree,
 as measured by characters.</div>
</td>
</tr>
<tr id="i59" class="rowColor">
<td class="colFirst"><code><a href="../../../../edu/stanford/nlp/trees/Tree.html" title="class in edu.stanford.nlp.trees">Tree</a></code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../../edu/stanford/nlp/trees/Tree.html#localTree--">localTree</a></span>()</code>
<div class="block">Returns a new Tree that represents the local Tree at a certain node.</div>
</td>
</tr>
<tr id="i60" class="altColor">
<td class="colFirst"><code>java.util.Set&lt;<a href="../../../../edu/stanford/nlp/trees/Tree.html" title="class in edu.stanford.nlp.trees">Tree</a>&gt;</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../../edu/stanford/nlp/trees/Tree.html#localTrees--">localTrees</a></span>()</code>
<div class="block">Returns a set of one level <code>Tree</code>s that ares the local trees
 of the tree.</div>
</td>
</tr>
<tr id="i61" class="rowColor">
<td class="colFirst"><code>java.util.Set&lt;<a href="../../../../edu/stanford/nlp/trees/Dependency.html" title="interface in edu.stanford.nlp.trees">Dependency</a>&lt;<a href="../../../../edu/stanford/nlp/ling/Label.html" title="interface in edu.stanford.nlp.ling">Label</a>,<a href="../../../../edu/stanford/nlp/ling/Label.html" title="interface in edu.stanford.nlp.ling">Label</a>,java.lang.Object&gt;&gt;</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../../edu/stanford/nlp/trees/Tree.html#mapDependencies-java.util.function.Predicate-edu.stanford.nlp.trees.HeadFinder-">mapDependencies</a></span>(java.util.function.Predicate&lt;<a href="../../../../edu/stanford/nlp/trees/Dependency.html" title="interface in edu.stanford.nlp.trees">Dependency</a>&lt;<a href="../../../../edu/stanford/nlp/ling/Label.html" title="interface in edu.stanford.nlp.ling">Label</a>,<a href="../../../../edu/stanford/nlp/ling/Label.html" title="interface in edu.stanford.nlp.ling">Label</a>,java.lang.Object&gt;&gt;&nbsp;f,
               <a href="../../../../edu/stanford/nlp/trees/HeadFinder.html" title="interface in edu.stanford.nlp.trees">HeadFinder</a>&nbsp;hf)</code>
<div class="block">Return a set of Label-Label dependencies, represented as
 Dependency objects, for the Tree.</div>
</td>
</tr>
<tr id="i62" class="altColor">
<td class="colFirst"><code>java.util.Set&lt;<a href="../../../../edu/stanford/nlp/trees/Dependency.html" title="interface in edu.stanford.nlp.trees">Dependency</a>&lt;<a href="../../../../edu/stanford/nlp/ling/Label.html" title="interface in edu.stanford.nlp.ling">Label</a>,<a href="../../../../edu/stanford/nlp/ling/Label.html" title="interface in edu.stanford.nlp.ling">Label</a>,java.lang.Object&gt;&gt;</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../../edu/stanford/nlp/trees/Tree.html#mapDependencies-java.util.function.Predicate-edu.stanford.nlp.trees.HeadFinder-java.lang.String-">mapDependencies</a></span>(java.util.function.Predicate&lt;<a href="../../../../edu/stanford/nlp/trees/Dependency.html" title="interface in edu.stanford.nlp.trees">Dependency</a>&lt;<a href="../../../../edu/stanford/nlp/ling/Label.html" title="interface in edu.stanford.nlp.ling">Label</a>,<a href="../../../../edu/stanford/nlp/ling/Label.html" title="interface in edu.stanford.nlp.ling">Label</a>,java.lang.Object&gt;&gt;&nbsp;f,
               <a href="../../../../edu/stanford/nlp/trees/HeadFinder.html" title="interface in edu.stanford.nlp.trees">HeadFinder</a>&nbsp;hf,
               java.lang.String&nbsp;rootName)</code>
<div class="block">Return a set of Label-Label dependencies, represented as
 Dependency objects, for the Tree.</div>
</td>
</tr>
<tr id="i63" class="rowColor">
<td class="colFirst"><code>int</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../../edu/stanford/nlp/trees/Tree.html#nodeNumber-edu.stanford.nlp.trees.Tree-">nodeNumber</a></span>(<a href="../../../../edu/stanford/nlp/trees/Tree.html" title="class in edu.stanford.nlp.trees">Tree</a>&nbsp;root)</code>
<div class="block">Calculates the node's <i>number</i>, defined as the number of nodes traversed in a left-to-right, depth-first search of the
 tree starting at <code>root</code> and ending at <code>this</code>.</div>
</td>
</tr>
<tr id="i64" class="altColor">
<td class="colFirst"><code>java.lang.String</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../../edu/stanford/nlp/trees/Tree.html#nodeString--">nodeString</a></span>()</code>
<div class="block">Returns the value of the nodes label as a String.</div>
</td>
</tr>
<tr id="i65" class="rowColor">
<td class="colFirst"><code>int</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../../edu/stanford/nlp/trees/Tree.html#numChildren--">numChildren</a></span>()</code>
<div class="block">Says how many children a tree node has in its local tree.</div>
</td>
</tr>
<tr id="i66" class="altColor">
<td class="colFirst"><code>int</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../../edu/stanford/nlp/trees/Tree.html#objectIndexOf-edu.stanford.nlp.trees.Tree-">objectIndexOf</a></span>(<a href="../../../../edu/stanford/nlp/trees/Tree.html" title="class in edu.stanford.nlp.trees">Tree</a>&nbsp;tree)</code>
<div class="block">Returns the position of a Tree in the children list, if present,
 or -1 if it is not present.</div>
</td>
</tr>
<tr id="i67" class="rowColor">
<td class="colFirst"><code><a href="../../../../edu/stanford/nlp/trees/Tree.html" title="class in edu.stanford.nlp.trees">Tree</a></code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../../edu/stanford/nlp/trees/Tree.html#parent--">parent</a></span>()</code>
<div class="block">Return the parent of the tree node.</div>
</td>
</tr>
<tr id="i68" class="altColor">
<td class="colFirst"><code><a href="../../../../edu/stanford/nlp/trees/Tree.html" title="class in edu.stanford.nlp.trees">Tree</a></code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../../edu/stanford/nlp/trees/Tree.html#parent-edu.stanford.nlp.trees.Tree-">parent</a></span>(<a href="../../../../edu/stanford/nlp/trees/Tree.html" title="class in edu.stanford.nlp.trees">Tree</a>&nbsp;root)</code>
<div class="block">Return the parent of the tree node.</div>
</td>
</tr>
<tr id="i69" class="rowColor">
<td class="colFirst"><code>java.util.List&lt;<a href="../../../../edu/stanford/nlp/trees/Tree.html" title="class in edu.stanford.nlp.trees">Tree</a>&gt;</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../../edu/stanford/nlp/trees/Tree.html#pathNodeToNode-edu.stanford.nlp.trees.Tree-edu.stanford.nlp.trees.Tree-">pathNodeToNode</a></span>(<a href="../../../../edu/stanford/nlp/trees/Tree.html" title="class in edu.stanford.nlp.trees">Tree</a>&nbsp;t1,
              <a href="../../../../edu/stanford/nlp/trees/Tree.html" title="class in edu.stanford.nlp.trees">Tree</a>&nbsp;t2)</code>
<div class="block">Given nodes <code>t1</code> and <code>t2</code> which are
 dominated by this node, returns a list of all the nodes on the
 path from t1 to t2, inclusive, or null if none found.</div>
</td>
</tr>
<tr id="i70" class="altColor">
<td class="colFirst"><code>void</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../../edu/stanford/nlp/trees/Tree.html#pennPrint--">pennPrint</a></span>()</code>
<div class="block">Print the tree as done in Penn Treebank merged files.</div>
</td>
</tr>
<tr id="i71" class="rowColor">
<td class="colFirst"><code>void</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../../edu/stanford/nlp/trees/Tree.html#pennPrint-java.io.PrintStream-">pennPrint</a></span>(java.io.PrintStream&nbsp;ps)</code>
<div class="block">Print the tree as done in Penn Treebank merged files.</div>
</td>
</tr>
<tr id="i72" class="altColor">
<td class="colFirst"><code>void</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../../edu/stanford/nlp/trees/Tree.html#pennPrint-java.io.PrintStream-boolean-">pennPrint</a></span>(java.io.PrintStream&nbsp;ps,
         boolean&nbsp;printOnlyLabelValue)</code>&nbsp;</td>
</tr>
<tr id="i73" class="rowColor">
<td class="colFirst"><code>void</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../../edu/stanford/nlp/trees/Tree.html#pennPrint-java.io.PrintWriter-">pennPrint</a></span>(java.io.PrintWriter&nbsp;pw)</code>
<div class="block">Print the tree as done in Penn Treebank merged files.</div>
</td>
</tr>
<tr id="i74" class="altColor">
<td class="colFirst"><code>void</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../../edu/stanford/nlp/trees/Tree.html#pennPrint-java.io.PrintWriter-boolean-">pennPrint</a></span>(java.io.PrintWriter&nbsp;pw,
         boolean&nbsp;printOnlyLabelValue)</code>&nbsp;</td>
</tr>
<tr id="i75" class="rowColor">
<td class="colFirst"><code>java.lang.String</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../../edu/stanford/nlp/trees/Tree.html#pennString--">pennString</a></span>()</code>
<div class="block">Calls <code>pennPrint()</code> and saves output to a String</div>
</td>
</tr>
<tr id="i76" class="altColor">
<td class="colFirst"><code>void</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../../edu/stanford/nlp/trees/Tree.html#percolateHeadAnnotations-edu.stanford.nlp.trees.HeadFinder-">percolateHeadAnnotations</a></span>(<a href="../../../../edu/stanford/nlp/trees/HeadFinder.html" title="interface in edu.stanford.nlp.trees">HeadFinder</a>&nbsp;hf)</code>
<div class="block">Finds the head words of each tree and assigns
 HeadWordLabelAnnotation on each node pointing to the correct
 CoreLabel.</div>
</td>
</tr>
<tr id="i77" class="rowColor">
<td class="colFirst"><code>void</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../../edu/stanford/nlp/trees/Tree.html#percolateHeadIndices--">percolateHeadIndices</a></span>()</code>
<div class="block">Percolates terminal indices through a dependency tree.</div>
</td>
</tr>
<tr id="i78" class="altColor">
<td class="colFirst"><code>void</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../../edu/stanford/nlp/trees/Tree.html#percolateHeads-edu.stanford.nlp.trees.HeadFinder-">percolateHeads</a></span>(<a href="../../../../edu/stanford/nlp/trees/HeadFinder.html" title="interface in edu.stanford.nlp.trees">HeadFinder</a>&nbsp;hf)</code>
<div class="block">Finds the heads of the tree.</div>
</td>
</tr>
<tr id="i79" class="rowColor">
<td class="colFirst"><code>java.util.List&lt;<a href="../../../../edu/stanford/nlp/trees/Tree.html" title="class in edu.stanford.nlp.trees">Tree</a>&gt;</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../../edu/stanford/nlp/trees/Tree.html#postOrderNodeList--">postOrderNodeList</a></span>()</code>&nbsp;</td>
</tr>
<tr id="i80" class="altColor">
<td class="colFirst"><code>java.util.List&lt;<a href="../../../../edu/stanford/nlp/trees/Tree.html" title="class in edu.stanford.nlp.trees">Tree</a>&gt;</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../../edu/stanford/nlp/trees/Tree.html#preOrderNodeList--">preOrderNodeList</a></span>()</code>&nbsp;</td>
</tr>
<tr id="i81" class="rowColor">
<td class="colFirst"><code>java.util.List&lt;<a href="../../../../edu/stanford/nlp/ling/Label.html" title="interface in edu.stanford.nlp.ling">Label</a>&gt;</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../../edu/stanford/nlp/trees/Tree.html#preTerminalYield--">preTerminalYield</a></span>()</code>
<div class="block">Gets the preterminal yield (i.e., tags) of the tree.</div>
</td>
</tr>
<tr id="i82" class="altColor">
<td class="colFirst"><code>java.util.List&lt;<a href="../../../../edu/stanford/nlp/ling/Label.html" title="interface in edu.stanford.nlp.ling">Label</a>&gt;</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../../edu/stanford/nlp/trees/Tree.html#preTerminalYield-java.util.List-">preTerminalYield</a></span>(java.util.List&lt;<a href="../../../../edu/stanford/nlp/ling/Label.html" title="interface in edu.stanford.nlp.ling">Label</a>&gt;&nbsp;y)</code>
<div class="block">Gets the preterminal yield (i.e., tags) of the tree.</div>
</td>
</tr>
<tr id="i83" class="rowColor">
<td class="colFirst"><code>void</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../../edu/stanford/nlp/trees/Tree.html#printLocalTree--">printLocalTree</a></span>()</code>&nbsp;</td>
</tr>
<tr id="i84" class="altColor">
<td class="colFirst"><code>void</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../../edu/stanford/nlp/trees/Tree.html#printLocalTree-java.io.PrintWriter-">printLocalTree</a></span>(java.io.PrintWriter&nbsp;pw)</code>
<div class="block">Only prints the local tree structure, does not recurse</div>
</td>
</tr>
<tr id="i85" class="rowColor">
<td class="colFirst"><code><a href="../../../../edu/stanford/nlp/trees/Tree.html" title="class in edu.stanford.nlp.trees">Tree</a></code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../../edu/stanford/nlp/trees/Tree.html#prune-java.util.function.Predicate-">prune</a></span>(java.util.function.Predicate&lt;<a href="../../../../edu/stanford/nlp/trees/Tree.html" title="class in edu.stanford.nlp.trees">Tree</a>&gt;&nbsp;filter)</code>
<div class="block">Creates a deep copy of the tree, where all nodes that the filter
 does not accept and all children of such nodes are pruned.</div>
</td>
</tr>
<tr id="i86" class="altColor">
<td class="colFirst"><code><a href="../../../../edu/stanford/nlp/trees/Tree.html" title="class in edu.stanford.nlp.trees">Tree</a></code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../../edu/stanford/nlp/trees/Tree.html#prune-java.util.function.Predicate-edu.stanford.nlp.trees.TreeFactory-">prune</a></span>(java.util.function.Predicate&lt;<a href="../../../../edu/stanford/nlp/trees/Tree.html" title="class in edu.stanford.nlp.trees">Tree</a>&gt;&nbsp;filter,
     <a href="../../../../edu/stanford/nlp/trees/TreeFactory.html" title="interface in edu.stanford.nlp.trees">TreeFactory</a>&nbsp;tf)</code>
<div class="block">Creates a deep copy of the tree, where all nodes that the filter
 does not accept and all children of such nodes are pruned.</div>
</td>
</tr>
<tr id="i87" class="rowColor">
<td class="colFirst"><code><a href="../../../../edu/stanford/nlp/trees/Tree.html" title="class in edu.stanford.nlp.trees">Tree</a></code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../../edu/stanford/nlp/trees/Tree.html#removeChild-int-">removeChild</a></span>(int&nbsp;i)</code>
<div class="block">Destructively removes the child at some daughter index and returns it.</div>
</td>
</tr>
<tr id="i88" class="altColor">
<td class="colFirst"><code>int</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../../edu/stanford/nlp/trees/Tree.html#rightCharEdge-edu.stanford.nlp.trees.Tree-">rightCharEdge</a></span>(<a href="../../../../edu/stanford/nlp/trees/Tree.html" title="class in edu.stanford.nlp.trees">Tree</a>&nbsp;node)</code>
<div class="block">Returns the positional index of the right edge of  <i>node</i> within the tree,
 as measured by characters.</div>
</td>
</tr>
<tr id="i89" class="rowColor">
<td class="colFirst"><code>double</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../../edu/stanford/nlp/trees/Tree.html#score--">score</a></span>()</code>
<div class="block">Returns the score associated with the current node, or NaN
 if there is no score.</div>
</td>
</tr>
<tr id="i90" class="altColor">
<td class="colFirst"><code><a href="../../../../edu/stanford/nlp/trees/Tree.html" title="class in edu.stanford.nlp.trees">Tree</a></code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../../edu/stanford/nlp/trees/Tree.html#setChild-int-edu.stanford.nlp.trees.Tree-">setChild</a></span>(int&nbsp;i,
        <a href="../../../../edu/stanford/nlp/trees/Tree.html" title="class in edu.stanford.nlp.trees">Tree</a>&nbsp;t)</code>
<div class="block">Replaces the <code>i</code>th child of <code>this</code> with the tree t.</div>
</td>
</tr>
<tr id="i91" class="rowColor">
<td class="colFirst"><code>void</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../../edu/stanford/nlp/trees/Tree.html#setChildren-java.util.List-">setChildren</a></span>(java.util.List&lt;? extends <a href="../../../../edu/stanford/nlp/trees/Tree.html" title="class in edu.stanford.nlp.trees">Tree</a>&gt;&nbsp;childTreesList)</code>
<div class="block">Set the children of this tree node to the given list.</div>
</td>
</tr>
<tr id="i92" class="altColor">
<td class="colFirst"><code>void</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../../edu/stanford/nlp/trees/Tree.html#setChildren-edu.stanford.nlp.trees.Tree:A-">setChildren</a></span>(<a href="../../../../edu/stanford/nlp/trees/Tree.html" title="class in edu.stanford.nlp.trees">Tree</a>[]&nbsp;children)</code>
<div class="block">Set the children of this node to be the children given in the
 array.</div>
</td>
</tr>
<tr id="i93" class="rowColor">
<td class="colFirst"><code>void</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../../edu/stanford/nlp/trees/Tree.html#setFromString-java.lang.String-">setFromString</a></span>(java.lang.String&nbsp;labelStr)</code>
<div class="block">Set the contents of this label to this <code>String</code>
 representing the
 complete contents of the label.</div>
</td>
</tr>
<tr id="i94" class="altColor">
<td class="colFirst"><code>void</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../../edu/stanford/nlp/trees/Tree.html#setLabel-edu.stanford.nlp.ling.Label-">setLabel</a></span>(<a href="../../../../edu/stanford/nlp/ling/Label.html" title="interface in edu.stanford.nlp.ling">Label</a>&nbsp;label)</code>
<div class="block">Sets the label associated with the current node, if there is one.</div>
</td>
</tr>
<tr id="i95" class="rowColor">
<td class="colFirst"><code>void</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../../edu/stanford/nlp/trees/Tree.html#setLabels-java.util.Collection-">setLabels</a></span>(java.util.Collection&lt;<a href="../../../../edu/stanford/nlp/ling/Label.html" title="interface in edu.stanford.nlp.ling">Label</a>&gt;&nbsp;c)</code>
<div class="block">Sets the labels associated with this object.</div>
</td>
</tr>
<tr id="i96" class="altColor">
<td class="colFirst"><code>void</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../../edu/stanford/nlp/trees/Tree.html#setScore-double-">setScore</a></span>(double&nbsp;score)</code>
<div class="block">Sets the score associated with the current node, if there is one.</div>
</td>
</tr>
<tr id="i97" class="rowColor">
<td class="colFirst"><code>void</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../../edu/stanford/nlp/trees/Tree.html#setSpans--">setSpans</a></span>()</code>
<div class="block">Assign a SpanAnnotation on each node of this tree.</div>
</td>
</tr>
<tr id="i98" class="altColor">
<td class="colFirst"><code>void</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../../edu/stanford/nlp/trees/Tree.html#setValue-java.lang.String-">setValue</a></span>(java.lang.String&nbsp;value)</code>
<div class="block">Set the value for the label (if one is stored).</div>
</td>
</tr>
<tr id="i99" class="rowColor">
<td class="colFirst"><code>java.util.List&lt;<a href="../../../../edu/stanford/nlp/trees/Tree.html" title="class in edu.stanford.nlp.trees">Tree</a>&gt;</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../../edu/stanford/nlp/trees/Tree.html#siblings-edu.stanford.nlp.trees.Tree-">siblings</a></span>(<a href="../../../../edu/stanford/nlp/trees/Tree.html" title="class in edu.stanford.nlp.trees">Tree</a>&nbsp;root)</code>
<div class="block">Returns the siblings of this Tree node.</div>
</td>
</tr>
<tr id="i100" class="altColor">
<td class="colFirst"><code>int</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../../edu/stanford/nlp/trees/Tree.html#size--">size</a></span>()</code>
<div class="block">Returns the number of nodes the tree contains.</div>
</td>
</tr>
<tr id="i101" class="rowColor">
<td class="colFirst"><code><a href="../../../../edu/stanford/nlp/trees/Tree.html" title="class in edu.stanford.nlp.trees">Tree</a></code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../../edu/stanford/nlp/trees/Tree.html#skipRoot--">skipRoot</a></span>()</code>
<div class="block">Returns first child if this is unary and if the label at the current
 node is either "ROOT" or empty.</div>
</td>
</tr>
<tr id="i102" class="altColor">
<td class="colFirst"><code><a href="../../../../edu/stanford/nlp/trees/Tree.html" title="class in edu.stanford.nlp.trees">Tree</a></code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../../edu/stanford/nlp/trees/Tree.html#spliceOut-java.util.function.Predicate-">spliceOut</a></span>(java.util.function.Predicate&lt;<a href="../../../../edu/stanford/nlp/trees/Tree.html" title="class in edu.stanford.nlp.trees">Tree</a>&gt;&nbsp;nodeFilter)</code>
<div class="block">Creates a (partial) deep copy of the tree, where all nodes that the
 filter does not accept are spliced out.</div>
</td>
</tr>
<tr id="i103" class="rowColor">
<td class="colFirst"><code><a href="../../../../edu/stanford/nlp/trees/Tree.html" title="class in edu.stanford.nlp.trees">Tree</a></code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../../edu/stanford/nlp/trees/Tree.html#spliceOut-java.util.function.Predicate-edu.stanford.nlp.trees.TreeFactory-">spliceOut</a></span>(java.util.function.Predicate&lt;<a href="../../../../edu/stanford/nlp/trees/Tree.html" title="class in edu.stanford.nlp.trees">Tree</a>&gt;&nbsp;nodeFilter,
         <a href="../../../../edu/stanford/nlp/trees/TreeFactory.html" title="interface in edu.stanford.nlp.trees">TreeFactory</a>&nbsp;tf)</code>
<div class="block">Creates a (partial) deep copy of the tree, where all nodes that the
 filter does not accept are spliced out.</div>
</td>
</tr>
<tr id="i104" class="altColor">
<td class="colFirst"><code>java.util.List&lt;<a href="../../../../edu/stanford/nlp/trees/Tree.html" title="class in edu.stanford.nlp.trees">Tree</a>&gt;</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../../edu/stanford/nlp/trees/Tree.html#subTreeList--">subTreeList</a></span>()</code>
<div class="block">Get the list of all subtrees inside the tree by returning a tree
 rooted at each node.</div>
</td>
</tr>
<tr id="i105" class="rowColor">
<td class="colFirst"><code>java.util.Set&lt;<a href="../../../../edu/stanford/nlp/trees/Tree.html" title="class in edu.stanford.nlp.trees">Tree</a>&gt;</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../../edu/stanford/nlp/trees/Tree.html#subTrees--">subTrees</a></span>()</code>
<div class="block">Get the set of all subtrees inside the tree by returning a tree
 rooted at each node.</div>
</td>
</tr>
<tr id="i106" class="altColor">
<td class="colFirst"><code>&lt;T extends java.util.Collection&lt;<a href="../../../../edu/stanford/nlp/trees/Tree.html" title="class in edu.stanford.nlp.trees">Tree</a>&gt;&gt;<br>T</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../../edu/stanford/nlp/trees/Tree.html#subTrees-T-">subTrees</a></span>(T&nbsp;n)</code>
<div class="block">Add the set of all subtrees inside a tree (including the tree itself)
 to the given <code>Collection</code>.</div>
</td>
</tr>
<tr id="i107" class="rowColor">
<td class="colFirst"><code>java.util.List&lt;<a href="../../../../edu/stanford/nlp/ling/CoreLabel.html" title="class in edu.stanford.nlp.ling">CoreLabel</a>&gt;</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../../edu/stanford/nlp/trees/Tree.html#taggedLabeledYield--">taggedLabeledYield</a></span>()</code>
<div class="block">Returns a <code>List&lt;CoreLabel&gt;</code> from the tree.</div>
</td>
</tr>
<tr id="i108" class="altColor">
<td class="colFirst"><code>java.util.ArrayList&lt;<a href="../../../../edu/stanford/nlp/ling/TaggedWord.html" title="class in edu.stanford.nlp.ling">TaggedWord</a>&gt;</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../../edu/stanford/nlp/trees/Tree.html#taggedYield--">taggedYield</a></span>()</code>
<div class="block">Gets the tagged yield of the tree.</div>
</td>
</tr>
<tr id="i109" class="rowColor">
<td class="colFirst"><code>&lt;X extends java.util.List&lt;<a href="../../../../edu/stanford/nlp/ling/TaggedWord.html" title="class in edu.stanford.nlp.ling">TaggedWord</a>&gt;&gt;<br>X</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../../edu/stanford/nlp/trees/Tree.html#taggedYield-X-">taggedYield</a></span>(X&nbsp;ty)</code>
<div class="block">Gets the tagged yield of the tree -- that is, get the preterminals
 as well as the terminals.</div>
</td>
</tr>
<tr id="i110" class="altColor">
<td class="colFirst"><code>java.lang.String</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../../edu/stanford/nlp/trees/Tree.html#toString--">toString</a></span>()</code>
<div class="block">Converts parse tree to string in Penn Treebank format.</div>
</td>
</tr>
<tr id="i111" class="rowColor">
<td class="colFirst"><code>java.lang.StringBuilder</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../../edu/stanford/nlp/trees/Tree.html#toStringBuilder-java.lang.StringBuilder-">toStringBuilder</a></span>(java.lang.StringBuilder&nbsp;sb)</code>
<div class="block">Appends the printed form of a parse tree (as a bracketed String)
 to a <code>StringBuilder</code>.</div>
</td>
</tr>
<tr id="i112" class="altColor">
<td class="colFirst"><code>java.lang.StringBuilder</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../../edu/stanford/nlp/trees/Tree.html#toStringBuilder-java.lang.StringBuilder-boolean-">toStringBuilder</a></span>(java.lang.StringBuilder&nbsp;sb,
               boolean&nbsp;printOnlyLabelValue)</code>
<div class="block">Appends the printed form of a parse tree (as a bracketed String)
 to a <code>StringBuilder</code>.</div>
</td>
</tr>
<tr id="i113" class="rowColor">
<td class="colFirst"><code><a href="../../../../edu/stanford/nlp/trees/Tree.html" title="class in edu.stanford.nlp.trees">Tree</a></code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../../edu/stanford/nlp/trees/Tree.html#transform-edu.stanford.nlp.trees.TreeTransformer-">transform</a></span>(<a href="../../../../edu/stanford/nlp/trees/TreeTransformer.html" title="interface in edu.stanford.nlp.trees">TreeTransformer</a>&nbsp;transformer)</code>
<div class="block">Create a transformed Tree.</div>
</td>
</tr>
<tr id="i114" class="altColor">
<td class="colFirst"><code><a href="../../../../edu/stanford/nlp/trees/Tree.html" title="class in edu.stanford.nlp.trees">Tree</a></code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../../edu/stanford/nlp/trees/Tree.html#transform-edu.stanford.nlp.trees.TreeTransformer-edu.stanford.nlp.trees.TreeFactory-">transform</a></span>(<a href="../../../../edu/stanford/nlp/trees/TreeTransformer.html" title="interface in edu.stanford.nlp.trees">TreeTransformer</a>&nbsp;transformer,
         <a href="../../../../edu/stanford/nlp/trees/TreeFactory.html" title="interface in edu.stanford.nlp.trees">TreeFactory</a>&nbsp;tf)</code>
<div class="block">Create a transformed Tree.</div>
</td>
</tr>
<tr id="i115" class="rowColor">
<td class="colFirst"><code>abstract <a href="../../../../edu/stanford/nlp/trees/TreeFactory.html" title="interface in edu.stanford.nlp.trees">TreeFactory</a></code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../../edu/stanford/nlp/trees/Tree.html#treeFactory--">treeFactory</a></span>()</code>
<div class="block">Return a <code>TreeFactory</code> that produces trees of the
 appropriate type.</div>
</td>
</tr>
<tr id="i116" class="altColor">
<td class="colFirst"><code><a href="../../../../edu/stanford/nlp/trees/Tree.html" title="class in edu.stanford.nlp.trees">Tree</a></code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../../edu/stanford/nlp/trees/Tree.html#treeSkeletonConstituentCopy--">treeSkeletonConstituentCopy</a></span>()</code>
<div class="block">Returns a deep copy of everything but the leaf labels.</div>
</td>
</tr>
<tr id="i117" class="rowColor">
<td class="colFirst"><code><a href="../../../../edu/stanford/nlp/trees/Tree.html" title="class in edu.stanford.nlp.trees">Tree</a></code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../../edu/stanford/nlp/trees/Tree.html#treeSkeletonConstituentCopy-edu.stanford.nlp.trees.TreeFactory-edu.stanford.nlp.ling.LabelFactory-">treeSkeletonConstituentCopy</a></span>(<a href="../../../../edu/stanford/nlp/trees/TreeFactory.html" title="interface in edu.stanford.nlp.trees">TreeFactory</a>&nbsp;tf,
                           <a href="../../../../edu/stanford/nlp/ling/LabelFactory.html" title="interface in edu.stanford.nlp.ling">LabelFactory</a>&nbsp;lf)</code>&nbsp;</td>
</tr>
<tr id="i118" class="altColor">
<td class="colFirst"><code><a href="../../../../edu/stanford/nlp/trees/Tree.html" title="class in edu.stanford.nlp.trees">Tree</a></code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../../edu/stanford/nlp/trees/Tree.html#treeSkeletonCopy--">treeSkeletonCopy</a></span>()</code>
<div class="block">Create a deep copy of the tree structure.</div>
</td>
</tr>
<tr id="i119" class="rowColor">
<td class="colFirst"><code><a href="../../../../edu/stanford/nlp/trees/Tree.html" title="class in edu.stanford.nlp.trees">Tree</a></code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../../edu/stanford/nlp/trees/Tree.html#treeSkeletonCopy-edu.stanford.nlp.trees.TreeFactory-">treeSkeletonCopy</a></span>(<a href="../../../../edu/stanford/nlp/trees/TreeFactory.html" title="interface in edu.stanford.nlp.trees">TreeFactory</a>&nbsp;tf)</code>
<div class="block">Create a deep copy of the tree structure.</div>
</td>
</tr>
<tr id="i120" class="altColor">
<td class="colFirst"><code><a href="../../../../edu/stanford/nlp/trees/Tree.html" title="class in edu.stanford.nlp.trees">Tree</a></code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../../edu/stanford/nlp/trees/Tree.html#upperMostUnary-edu.stanford.nlp.trees.Tree-">upperMostUnary</a></span>(<a href="../../../../edu/stanford/nlp/trees/Tree.html" title="class in edu.stanford.nlp.trees">Tree</a>&nbsp;root)</code>
<div class="block">Return the highest node of the (perhaps trivial) unary chain that
  this node is part of.</div>
</td>
</tr>
<tr id="i121" class="rowColor">
<td class="colFirst"><code>java.lang.String</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../../edu/stanford/nlp/trees/Tree.html#value--">value</a></span>()</code>
<div class="block">Return a String representation of just the "main" value of this label.</div>
</td>
</tr>
<tr id="i122" class="altColor">
<td class="colFirst"><code>static <a href="../../../../edu/stanford/nlp/trees/Tree.html" title="class in edu.stanford.nlp.trees">Tree</a></code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../../edu/stanford/nlp/trees/Tree.html#valueOf-java.lang.String-">valueOf</a></span>(java.lang.String&nbsp;str)</code>
<div class="block">This gives you a tree from a String representation (as a
 bracketed Tree, of the kind produced by <code>toString()</code>,
 <code>pennPrint()</code>, or as in the Penn Treebank).</div>
</td>
</tr>
<tr id="i123" class="rowColor">
<td class="colFirst"><code>static <a href="../../../../edu/stanford/nlp/trees/Tree.html" title="class in edu.stanford.nlp.trees">Tree</a></code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../../edu/stanford/nlp/trees/Tree.html#valueOf-java.lang.String-edu.stanford.nlp.trees.TreeReaderFactory-">valueOf</a></span>(java.lang.String&nbsp;str,
       <a href="../../../../edu/stanford/nlp/trees/TreeReaderFactory.html" title="interface in edu.stanford.nlp.trees">TreeReaderFactory</a>&nbsp;trf)</code>
<div class="block">This gives you a tree from a String representation (as a
 bracketed Tree, of the kind produced by <code>toString()</code>,
 <code>pennPrint()</code>, or as in the Penn Treebank.</div>
</td>
</tr>
<tr id="i124" class="altColor">
<td class="colFirst"><code>java.util.ArrayList&lt;<a href="../../../../edu/stanford/nlp/ling/Label.html" title="interface in edu.stanford.nlp.ling">Label</a>&gt;</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../../edu/stanford/nlp/trees/Tree.html#yield--">yield</a></span>()</code>
<div class="block">Gets the yield of the tree.</div>
</td>
</tr>
<tr id="i125" class="rowColor">
<td class="colFirst"><code>java.util.ArrayList&lt;<a href="../../../../edu/stanford/nlp/ling/Label.html" title="interface in edu.stanford.nlp.ling">Label</a>&gt;</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../../edu/stanford/nlp/trees/Tree.html#yield-java.util.ArrayList-">yield</a></span>(java.util.ArrayList&lt;<a href="../../../../edu/stanford/nlp/ling/Label.html" title="interface in edu.stanford.nlp.ling">Label</a>&gt;&nbsp;y)</code>
<div class="block">Gets the yield of the tree.</div>
</td>
</tr>
<tr id="i126" class="altColor">
<td class="colFirst"><code>&lt;T&gt;&nbsp;java.util.List&lt;T&gt;</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../../edu/stanford/nlp/trees/Tree.html#yield-java.util.List-">yield</a></span>(java.util.List&lt;T&gt;&nbsp;y)</code>
<div class="block">Gets the yield of the tree.</div>
</td>
</tr>
<tr id="i127" class="rowColor">
<td class="colFirst"><code>&lt;X extends <a href="../../../../edu/stanford/nlp/ling/HasWord.html" title="interface in edu.stanford.nlp.ling">HasWord</a>&gt;<br>java.util.ArrayList&lt;X&gt;</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../../edu/stanford/nlp/trees/Tree.html#yieldHasWord--">yieldHasWord</a></span>()</code>&nbsp;</td>
</tr>
<tr id="i128" class="altColor">
<td class="colFirst"><code>&lt;X extends <a href="../../../../edu/stanford/nlp/ling/HasWord.html" title="interface in edu.stanford.nlp.ling">HasWord</a>&gt;<br>java.util.ArrayList&lt;X&gt;</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../../edu/stanford/nlp/trees/Tree.html#yieldHasWord-java.util.ArrayList-">yieldHasWord</a></span>(java.util.ArrayList&lt;X&gt;&nbsp;y)</code>&nbsp;</td>
</tr>
<tr id="i129" class="rowColor">
<td class="colFirst"><code>java.util.ArrayList&lt;<a href="../../../../edu/stanford/nlp/ling/Word.html" title="class in edu.stanford.nlp.ling">Word</a>&gt;</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../../edu/stanford/nlp/trees/Tree.html#yieldWords--">yieldWords</a></span>()</code>&nbsp;</td>
</tr>
<tr id="i130" class="altColor">
<td class="colFirst"><code>java.util.ArrayList&lt;<a href="../../../../edu/stanford/nlp/ling/Word.html" title="class in edu.stanford.nlp.ling">Word</a>&gt;</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../../edu/stanford/nlp/trees/Tree.html#yieldWords-java.util.ArrayList-">yieldWords</a></span>(java.util.ArrayList&lt;<a href="../../../../edu/stanford/nlp/ling/Word.html" title="class in edu.stanford.nlp.ling">Word</a>&gt;&nbsp;y)</code>&nbsp;</td>
</tr>
</table>
<ul class="blockList">
<li class="blockList"><a name="methods.inherited.from.class.java.util.AbstractCollection">
<!--   -->
</a>
<h3>Methods inherited from class&nbsp;java.util.AbstractCollection</h3>
<code>add, addAll, clear, contains, containsAll, isEmpty, remove, removeAll, retainAll, toArray, toArray</code></li>
</ul>
<ul class="blockList">
<li class="blockList"><a name="methods.inherited.from.class.java.lang.Object">
<!--   -->
</a>
<h3>Methods inherited from class&nbsp;java.lang.Object</h3>
<code>clone, finalize, getClass, notify, notifyAll, wait, wait, wait</code></li>
</ul>
<ul class="blockList">
<li class="blockList"><a name="methods.inherited.from.class.java.util.Collection">
<!--   -->
</a>
<h3>Methods inherited from interface&nbsp;java.util.Collection</h3>
<code>parallelStream, removeIf, spliterator, stream</code></li>
</ul>
<ul class="blockList">
<li class="blockList"><a name="methods.inherited.from.class.java.lang.Iterable">
<!--   -->
</a>
<h3>Methods inherited from interface&nbsp;java.lang.Iterable</h3>
<code>forEach</code></li>
</ul>
</li>
</ul>
</li>
</ul>
</div>
<div class="details">
<ul class="blockList">
<li class="blockList">
<!-- ============ FIELD DETAIL =========== -->
<ul class="blockList">
<li class="blockList"><a name="field.detail">
<!--   -->
</a>
<h3>Field Detail</h3>
<a name="EMPTY_TREE_ARRAY">
<!--   -->
</a>
<ul class="blockListLast">
<li class="blockList">
<h4>EMPTY_TREE_ARRAY</h4>
<pre>public static final&nbsp;<a href="../../../../edu/stanford/nlp/trees/Tree.html" title="class in edu.stanford.nlp.trees">Tree</a>[] EMPTY_TREE_ARRAY</pre>
<div class="block">A leaf node should have a zero-length array for its
 children. For efficiency, classes can use this array as a
 return value for children() for leaf nodes if desired.
 This can also be used elsewhere when you want an empty Tree array.</div>
</li>
</ul>
</li>
</ul>
<!-- ========= CONSTRUCTOR DETAIL ======== -->
<ul class="blockList">
<li class="blockList"><a name="constructor.detail">
<!--   -->
</a>
<h3>Constructor Detail</h3>
<a name="Tree--">
<!--   -->
</a>
<ul class="blockListLast">
<li class="blockList">
<h4>Tree</h4>
<pre>public&nbsp;Tree()</pre>
</li>
</ul>
</li>
</ul>
<!-- ============ METHOD DETAIL ========== -->
<ul class="blockList">
<li class="blockList"><a name="method.detail">
<!--   -->
</a>
<h3>Method Detail</h3>
<a name="isLeaf--">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>isLeaf</h4>
<pre>public&nbsp;boolean&nbsp;isLeaf()</pre>
<div class="block">Says whether a node is a leaf.  Can be used on an arbitrary
 <code>Tree</code>.  Being a leaf is defined as having no
 children.  This must be implemented as returning a zero-length
 Tree[] array for children().</div>
<dl>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>true if this object is a leaf</dd>
</dl>
</li>
</ul>
<a name="numChildren--">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>numChildren</h4>
<pre>public&nbsp;int&nbsp;numChildren()</pre>
<div class="block">Says how many children a tree node has in its local tree.
 Can be used on an arbitrary <code>Tree</code>.  Being a leaf is defined
 as having no children.</div>
<dl>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>The number of direct children of the tree node</dd>
</dl>
</li>
</ul>
<a name="isUnaryRewrite--">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>isUnaryRewrite</h4>
<pre>public&nbsp;boolean&nbsp;isUnaryRewrite()</pre>
<div class="block">Says whether the current node has only one child.
 Can be used on an arbitrary <code>Tree</code>.</div>
<dl>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>Whether the node heads a unary rewrite</dd>
</dl>
</li>
</ul>
<a name="isPreTerminal--">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>isPreTerminal</h4>
<pre>public&nbsp;boolean&nbsp;isPreTerminal()</pre>
<div class="block">Return whether this node is a preterminal or not.  A preterminal is
 defined to be a node with one child which is itself a leaf.</div>
<dl>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>true if the node is a preterminal; false otherwise</dd>
</dl>
</li>
</ul>
<a name="isPrePreTerminal--">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>isPrePreTerminal</h4>
<pre>public&nbsp;boolean&nbsp;isPrePreTerminal()</pre>
<div class="block">Return whether all the children of this node are preterminals or not.
 A preterminal is
 defined to be a node with one child which is itself a leaf.
 Considered false if the node has no children</div>
<dl>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>true if the node is a prepreterminal; false otherwise</dd>
</dl>
</li>
</ul>
<a name="isPhrasal--">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>isPhrasal</h4>
<pre>public&nbsp;boolean&nbsp;isPhrasal()</pre>
<div class="block">Return whether this node is a phrasal node or not.  A phrasal node
 is defined to be a node which is not a leaf or a preterminal.
 Worded positively, this means that it must have two or more children,
 or one child that is not a leaf.</div>
<dl>
<dt><span class="returnLabel">Returns:</span></dt>
<dd><code>true</code> if the node is phrasal;
         <code>false</code> otherwise</dd>
</dl>
</li>
</ul>
<a name="equals-java.lang.Object-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>equals</h4>
<pre>public&nbsp;boolean&nbsp;equals(java.lang.Object&nbsp;o)</pre>
<div class="block">Implements equality for Tree's.  Two Tree objects are equal if they
 have equal <a href="../../../../edu/stanford/nlp/trees/Tree.html#value--"><code>value()</code></a>s, the same number of children, and their children
 are pairwise equal.</div>
<dl>
<dt><span class="overrideSpecifyLabel">Specified by:</span></dt>
<dd><code>equals</code>&nbsp;in interface&nbsp;<code>java.util.Collection&lt;<a href="../../../../edu/stanford/nlp/trees/Tree.html" title="class in edu.stanford.nlp.trees">Tree</a>&gt;</code></dd>
<dt><span class="overrideSpecifyLabel">Overrides:</span></dt>
<dd><code>equals</code>&nbsp;in class&nbsp;<code>java.lang.Object</code></dd>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>o</code> - The object to compare with</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>Whether two things are equal</dd>
</dl>
</li>
</ul>
<a name="hashCode--">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>hashCode</h4>
<pre>public&nbsp;int&nbsp;hashCode()</pre>
<div class="block">Implements a hashCode for Tree's.  Two trees should have the same
 hashcode if they are equal, so we hash on the label value and
 the children's label values.</div>
<dl>
<dt><span class="overrideSpecifyLabel">Specified by:</span></dt>
<dd><code>hashCode</code>&nbsp;in interface&nbsp;<code>java.util.Collection&lt;<a href="../../../../edu/stanford/nlp/trees/Tree.html" title="class in edu.stanford.nlp.trees">Tree</a>&gt;</code></dd>
<dt><span class="overrideSpecifyLabel">Overrides:</span></dt>
<dd><code>hashCode</code>&nbsp;in class&nbsp;<code>java.lang.Object</code></dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>The hash code</dd>
</dl>
</li>
</ul>
<a name="objectIndexOf-edu.stanford.nlp.trees.Tree-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>objectIndexOf</h4>
<pre>public&nbsp;int&nbsp;objectIndexOf(<a href="../../../../edu/stanford/nlp/trees/Tree.html" title="class in edu.stanford.nlp.trees">Tree</a>&nbsp;tree)</pre>
<div class="block">Returns the position of a Tree in the children list, if present,
 or -1 if it is not present.  Trees are checked for presence with
 object equality, ==.  Note that there are very few cases where an
 indexOf that used .equals() instead of == would be useful and
 correct.  In most cases, you want to figure out which child of
 the parent a known tree is, so looking for object equality will
 be faster and will avoid cases where you happen to have two
 subtrees that are exactly the same.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>tree</code> - The tree to look for in children list</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>Its index in the list or -1</dd>
</dl>
</li>
</ul>
<a name="children--">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>children</h4>
<pre>public abstract&nbsp;<a href="../../../../edu/stanford/nlp/trees/Tree.html" title="class in edu.stanford.nlp.trees">Tree</a>[]&nbsp;children()</pre>
<div class="block">Returns an array of children for the current node.  If there
 are no children (if the node is a leaf), this must return a
 Tree[] array of length 0.  A null children() value for tree
 leaves was previously supported, but no longer is.
 A caller may assume that either <code>isLeaf()</code> returns
 true, or this node has a nonzero number of children.</div>
<dl>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>The children of the node</dd>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="../../../../edu/stanford/nlp/trees/Tree.html#getChildrenAsList--"><code>getChildrenAsList()</code></a></dd>
</dl>
</li>
</ul>
<a name="getChildrenAsList--">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>getChildrenAsList</h4>
<pre>public&nbsp;java.util.List&lt;<a href="../../../../edu/stanford/nlp/trees/Tree.html" title="class in edu.stanford.nlp.trees">Tree</a>&gt;&nbsp;getChildrenAsList()</pre>
<div class="block">Returns a List of children for the current node.  If there are no
 children, then a (non-null) <code>List&lt;Tree&gt;</code> of size 0 will
 be returned.  The list has new list structure but pointers to,
 not copies of the children.  That is, the returned list is mutable,
 and simply adding to or deleting items from it is safe, but beware
 changing the contents of the children.</div>
<dl>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>The children of the node</dd>
</dl>
</li>
</ul>
<a name="setChildren-edu.stanford.nlp.trees.Tree:A-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>setChildren</h4>
<pre>public&nbsp;void&nbsp;setChildren(<a href="../../../../edu/stanford/nlp/trees/Tree.html" title="class in edu.stanford.nlp.trees">Tree</a>[]&nbsp;children)</pre>
<div class="block">Set the children of this node to be the children given in the
 array.  This is an <b>optional</b> operation; by default it is
 unsupported.  Note for subclasses that if there are no
 children, the children() method must return a Tree[] array of
 length 0.  This class provides a
 <code>EMPTY_TREE_ARRAY</code> canonical zero-length Tree[] array
 to represent zero children, but it is <i>not</i> required that
 leaf nodes use this particular zero-length array to represent
 a leaf node.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>children</code> - The array of children, each a <code>Tree</code></dd>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="../../../../edu/stanford/nlp/trees/Tree.html#setChildren-java.util.List-"><code>setChildren(List)</code></a></dd>
</dl>
</li>
</ul>
<a name="setChildren-java.util.List-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>setChildren</h4>
<pre>public&nbsp;void&nbsp;setChildren(java.util.List&lt;? extends <a href="../../../../edu/stanford/nlp/trees/Tree.html" title="class in edu.stanford.nlp.trees">Tree</a>&gt;&nbsp;childTreesList)</pre>
<div class="block">Set the children of this tree node to the given list.  This
 method is implemented in the <code>Tree</code> class by
 converting the <code>List</code> into a tree array and calling
 the array-based method.  Subclasses which use a
 <code>List</code>-based representation of tree children should
 override this method.  This implementation allows the case
 that the <code>List</code> is <code>null</code>: it yields a
 node with no children (represented by a canonical zero-length
 children() array).</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>childTreesList</code> - A list of trees to become children of the node.
          This method does not retain the List that you pass it (copying
          is done), but it will retain the individual children (they are
          not copied).</dd>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="../../../../edu/stanford/nlp/trees/Tree.html#setChildren-edu.stanford.nlp.trees.Tree:A-"><code>setChildren(Tree[])</code></a></dd>
</dl>
</li>
</ul>
<a name="label--">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>label</h4>
<pre>public&nbsp;<a href="../../../../edu/stanford/nlp/ling/Label.html" title="interface in edu.stanford.nlp.ling">Label</a>&nbsp;label()</pre>
<div class="block">Returns the label associated with the current node, or null
 if there is no label.  The default implementation always
 returns <code>null</code>.</div>
<dl>
<dt><span class="overrideSpecifyLabel">Specified by:</span></dt>
<dd><code><a href="../../../../edu/stanford/nlp/trees/Labeled.html#label--">label</a></code>&nbsp;in interface&nbsp;<code><a href="../../../../edu/stanford/nlp/trees/Labeled.html" title="interface in edu.stanford.nlp.trees">Labeled</a></code></dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>The label of the node</dd>
</dl>
</li>
</ul>
<a name="setLabel-edu.stanford.nlp.ling.Label-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>setLabel</h4>
<pre>public&nbsp;void&nbsp;setLabel(<a href="../../../../edu/stanford/nlp/ling/Label.html" title="interface in edu.stanford.nlp.ling">Label</a>&nbsp;label)</pre>
<div class="block">Sets the label associated with the current node, if there is one.
 The default implementation ignores the label.</div>
<dl>
<dt><span class="overrideSpecifyLabel">Specified by:</span></dt>
<dd><code><a href="../../../../edu/stanford/nlp/trees/Labeled.html#setLabel-edu.stanford.nlp.ling.Label-">setLabel</a></code>&nbsp;in interface&nbsp;<code><a href="../../../../edu/stanford/nlp/trees/Labeled.html" title="interface in edu.stanford.nlp.trees">Labeled</a></code></dd>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>label</code> - The label</dd>
</dl>
</li>
</ul>
<a name="score--">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>score</h4>
<pre>public&nbsp;double&nbsp;score()</pre>
<div class="block">Returns the score associated with the current node, or NaN
 if there is no score.  The default implementation returns NaN.</div>
<dl>
<dt><span class="overrideSpecifyLabel">Specified by:</span></dt>
<dd><code><a href="../../../../edu/stanford/nlp/util/Scored.html#score--">score</a></code>&nbsp;in interface&nbsp;<code><a href="../../../../edu/stanford/nlp/util/Scored.html" title="interface in edu.stanford.nlp.util">Scored</a></code></dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>The score</dd>
</dl>
</li>
</ul>
<a name="setScore-double-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>setScore</h4>
<pre>public&nbsp;void&nbsp;setScore(double&nbsp;score)</pre>
<div class="block">Sets the score associated with the current node, if there is one.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>score</code> - The score</dd>
</dl>
</li>
</ul>
<a name="firstChild--">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>firstChild</h4>
<pre>public&nbsp;<a href="../../../../edu/stanford/nlp/trees/Tree.html" title="class in edu.stanford.nlp.trees">Tree</a>&nbsp;firstChild()</pre>
<div class="block">Returns the first child of a tree, or <code>null</code> if none.</div>
<dl>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>The first child</dd>
</dl>
</li>
</ul>
<a name="lastChild--">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>lastChild</h4>
<pre>public&nbsp;<a href="../../../../edu/stanford/nlp/trees/Tree.html" title="class in edu.stanford.nlp.trees">Tree</a>&nbsp;lastChild()</pre>
<div class="block">Returns the last child of a tree, or <code>null</code> if none.</div>
<dl>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>The last child</dd>
</dl>
</li>
</ul>
<a name="upperMostUnary-edu.stanford.nlp.trees.Tree-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>upperMostUnary</h4>
<pre>public&nbsp;<a href="../../../../edu/stanford/nlp/trees/Tree.html" title="class in edu.stanford.nlp.trees">Tree</a>&nbsp;upperMostUnary(<a href="../../../../edu/stanford/nlp/trees/Tree.html" title="class in edu.stanford.nlp.trees">Tree</a>&nbsp;root)</pre>
<div class="block">Return the highest node of the (perhaps trivial) unary chain that
  this node is part of.
  In case this node is the only child of its parent, trace up the chain of
  unaries, and return the uppermost node of the chain (the node whose
  parent has multiple children, or the node that is the root of the tree).</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>root</code> - The root of the tree that contains this subtree</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>The uppermost node of the unary chain, if this node is in a unary
         chain, or else the current node</dd>
</dl>
</li>
</ul>
<a name="setSpans--">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>setSpans</h4>
<pre>public&nbsp;void&nbsp;setSpans()</pre>
<div class="block">Assign a SpanAnnotation on each node of this tree.
  The index starts at zero.</div>
</li>
</ul>
<a name="getSpan--">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>getSpan</h4>
<pre>public&nbsp;<a href="../../../../edu/stanford/nlp/util/IntPair.html" title="class in edu.stanford.nlp.util">IntPair</a>&nbsp;getSpan()</pre>
<div class="block">Returns SpanAnnotation of this node, or null if annotation is not assigned.
 Use <code>setSpans()</code> to assign SpanAnnotations to a tree.</div>
<dl>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>an IntPair: the SpanAnnotation of this node.</dd>
</dl>
</li>
</ul>
<a name="constituents--">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>constituents</h4>
<pre>public&nbsp;java.util.Set&lt;<a href="../../../../edu/stanford/nlp/trees/Constituent.html" title="class in edu.stanford.nlp.trees">Constituent</a>&gt;&nbsp;constituents()</pre>
<div class="block">Returns the Constituents generated by the parse tree. Constituents
 are computed with respect to whitespace (e.g., at the word level).</div>
<dl>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>a Set of the constituents as constituents of
         type <code>Constituent</code></dd>
</dl>
</li>
</ul>
<a name="constituents-edu.stanford.nlp.trees.ConstituentFactory-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>constituents</h4>
<pre>public&nbsp;java.util.Set&lt;<a href="../../../../edu/stanford/nlp/trees/Constituent.html" title="class in edu.stanford.nlp.trees">Constituent</a>&gt;&nbsp;constituents(<a href="../../../../edu/stanford/nlp/trees/ConstituentFactory.html" title="interface in edu.stanford.nlp.trees">ConstituentFactory</a>&nbsp;cf)</pre>
<div class="block">Returns the Constituents generated by the parse tree.
 The Constituents of a sentence include the preterminal categories
 but not the leaves.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>cf</code> - ConstituentFactory used to build the Constituent objects</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>a Set of the constituents as SimpleConstituent type
         (in the current implementation, a <code>HashSet</code></dd>
</dl>
</li>
</ul>
<a name="constituents-edu.stanford.nlp.trees.ConstituentFactory-int-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>constituents</h4>
<pre>public&nbsp;java.util.Set&lt;<a href="../../../../edu/stanford/nlp/trees/Constituent.html" title="class in edu.stanford.nlp.trees">Constituent</a>&gt;&nbsp;constituents(<a href="../../../../edu/stanford/nlp/trees/ConstituentFactory.html" title="interface in edu.stanford.nlp.trees">ConstituentFactory</a>&nbsp;cf,
                                               int&nbsp;maxDepth)</pre>
<div class="block">Returns the Constituents generated by the parse tree.
 The Constituents of a sentence include the preterminal categories
 but not the leaves.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>cf</code> - ConstituentFactory used to build the Constituent objects</dd>
<dd><code>maxDepth</code> - The maximum depth at which to add constituents,
                 where 0 is the root level.  Negative maxDepth
                 indicates no maximum.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>a Set of the constituents as SimpleConstituent type
         (in the current implementation, a <code>HashSet</code></dd>
</dl>
</li>
</ul>
<a name="constituents-edu.stanford.nlp.trees.ConstituentFactory-boolean-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>constituents</h4>
<pre>public&nbsp;java.util.Set&lt;<a href="../../../../edu/stanford/nlp/trees/Constituent.html" title="class in edu.stanford.nlp.trees">Constituent</a>&gt;&nbsp;constituents(<a href="../../../../edu/stanford/nlp/trees/ConstituentFactory.html" title="interface in edu.stanford.nlp.trees">ConstituentFactory</a>&nbsp;cf,
                                               boolean&nbsp;charLevel)</pre>
<div class="block">Returns the Constituents generated by the parse tree.
 The Constituents of a sentence include the preterminal categories
 but not the leaves.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>cf</code> - ConstituentFactory used to build the Constituent objects</dd>
<dd><code>charLevel</code> - If true, compute bracketings irrespective of whitespace boundaries.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>a Set of the constituents as SimpleConstituent type
         (in the current implementation, a <code>HashSet</code></dd>
</dl>
</li>
</ul>
<a name="constituents-edu.stanford.nlp.trees.ConstituentFactory-boolean-java.util.function.Predicate-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>constituents</h4>
<pre>public&nbsp;java.util.Set&lt;<a href="../../../../edu/stanford/nlp/trees/Constituent.html" title="class in edu.stanford.nlp.trees">Constituent</a>&gt;&nbsp;constituents(<a href="../../../../edu/stanford/nlp/trees/ConstituentFactory.html" title="interface in edu.stanford.nlp.trees">ConstituentFactory</a>&nbsp;cf,
                                               boolean&nbsp;charLevel,
                                               java.util.function.Predicate&lt;<a href="../../../../edu/stanford/nlp/trees/Tree.html" title="class in edu.stanford.nlp.trees">Tree</a>&gt;&nbsp;filter)</pre>
</li>
</ul>
<a name="localTree--">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>localTree</h4>
<pre>public&nbsp;<a href="../../../../edu/stanford/nlp/trees/Tree.html" title="class in edu.stanford.nlp.trees">Tree</a>&nbsp;localTree()</pre>
<div class="block">Returns a new Tree that represents the local Tree at a certain node.
 That is, it builds a new tree that copies the mother and daughter
 nodes (but not their Labels), as non-Leaf nodes,
 but zeroes out their children.</div>
<dl>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>A local tree</dd>
</dl>
</li>
</ul>
<a name="localTrees--">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>localTrees</h4>
<pre>public&nbsp;java.util.Set&lt;<a href="../../../../edu/stanford/nlp/trees/Tree.html" title="class in edu.stanford.nlp.trees">Tree</a>&gt;&nbsp;localTrees()</pre>
<div class="block">Returns a set of one level <code>Tree</code>s that ares the local trees
 of the tree.
 That is, it builds a new tree that copies the mother and daughter
 nodes (but not their Labels), for each phrasal node,
 but zeroes out their children.</div>
<dl>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>A set of local tree</dd>
</dl>
</li>
</ul>
<a name="toStringBuilder-java.lang.StringBuilder-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>toStringBuilder</h4>
<pre>public&nbsp;java.lang.StringBuilder&nbsp;toStringBuilder(java.lang.StringBuilder&nbsp;sb)</pre>
<div class="block">Appends the printed form of a parse tree (as a bracketed String)
 to a <code>StringBuilder</code>.
 The implementation of this may be more efficient than for
 <code>toString()</code> on complex trees.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>sb</code> - The <code>StringBuilder</code> to which the tree will be appended</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>Returns the <code>StringBuilder</code> passed in with extra stuff in it</dd>
</dl>
</li>
</ul>
<a name="toStringBuilder-java.lang.StringBuilder-boolean-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>toStringBuilder</h4>
<pre>public&nbsp;java.lang.StringBuilder&nbsp;toStringBuilder(java.lang.StringBuilder&nbsp;sb,
                                               boolean&nbsp;printOnlyLabelValue)</pre>
<div class="block">Appends the printed form of a parse tree (as a bracketed String)
 to a <code>StringBuilder</code>.
 The implementation of this may be more efficient than for
 <code>toString()</code> on complex trees.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>sb</code> - The <code>StringBuilder</code> to which the tree will be appended</dd>
<dd><code>printOnlyLabelValue</code> - If true, print only the value() of each node's label</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>Returns the <code>StringBuilder</code> passed in with extra stuff in it</dd>
</dl>
</li>
</ul>
<a name="toString--">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>toString</h4>
<pre>public&nbsp;java.lang.String&nbsp;toString()</pre>
<div class="block">Converts parse tree to string in Penn Treebank format.
 <p>
 Implementation note: Internally, the method gains
 efficiency by chaining use of a single <code>StringBuilder</code>
 through all the printing.</div>
<dl>
<dt><span class="overrideSpecifyLabel">Specified by:</span></dt>
<dd><code><a href="../../../../edu/stanford/nlp/ling/Label.html#toString--">toString</a></code>&nbsp;in interface&nbsp;<code><a href="../../../../edu/stanford/nlp/ling/Label.html" title="interface in edu.stanford.nlp.ling">Label</a></code></dd>
<dt><span class="overrideSpecifyLabel">Overrides:</span></dt>
<dd><code>toString</code>&nbsp;in class&nbsp;<code>java.util.AbstractCollection&lt;<a href="../../../../edu/stanford/nlp/trees/Tree.html" title="class in edu.stanford.nlp.trees">Tree</a>&gt;</code></dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>the tree as a bracketed list on one line</dd>
</dl>
</li>
</ul>
<a name="printLocalTree--">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>printLocalTree</h4>
<pre>public&nbsp;void&nbsp;printLocalTree()</pre>
</li>
</ul>
<a name="printLocalTree-java.io.PrintWriter-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>printLocalTree</h4>
<pre>public&nbsp;void&nbsp;printLocalTree(java.io.PrintWriter&nbsp;pw)</pre>
<div class="block">Only prints the local tree structure, does not recurse</div>
</li>
</ul>
<a name="indentedListPrint--">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>indentedListPrint</h4>
<pre>public&nbsp;void&nbsp;indentedListPrint()</pre>
<div class="block">Indented list printing of a tree.  The tree is printed in an
 indented list notation, with node labels followed by node scores.</div>
</li>
</ul>
<a name="indentedListPrint-java.io.PrintWriter-boolean-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>indentedListPrint</h4>
<pre>public&nbsp;void&nbsp;indentedListPrint(java.io.PrintWriter&nbsp;pw,
                              boolean&nbsp;printScores)</pre>
<div class="block">Indented list printing of a tree.  The tree is printed in an
 indented list notation, with node labels followed by node scores.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>pw</code> - The PrintWriter to print the tree to</dd>
<dd><code>printScores</code> - Whether to print the scores (log probs) of tree nodes</dd>
</dl>
</li>
</ul>
<a name="indentedXMLPrint--">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>indentedXMLPrint</h4>
<pre>public&nbsp;void&nbsp;indentedXMLPrint()</pre>
<div class="block">Indented xml printing of a tree.  The tree is printed in an
 indented xml notation.</div>
</li>
</ul>
<a name="indentedXMLPrint-java.io.PrintWriter-boolean-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>indentedXMLPrint</h4>
<pre>public&nbsp;void&nbsp;indentedXMLPrint(java.io.PrintWriter&nbsp;pw,
                             boolean&nbsp;printScores)</pre>
<div class="block">Indented xml printing of a tree.  The tree is printed in an
 indented xml notation, with node labels followed by node scores.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>pw</code> - The PrintWriter to print the tree to</dd>
<dd><code>printScores</code> - Whether to print the scores (log probs) of tree nodes</dd>
</dl>
</li>
</ul>
<a name="nodeString--">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>nodeString</h4>
<pre>public&nbsp;java.lang.String&nbsp;nodeString()</pre>
<div class="block">Returns the value of the nodes label as a String.  This is done by
  calling <code>toString()</code> on the value, if it exists. Otherwise,
  an empty string is returned.</div>
<dl>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>The label of a tree node as a String</dd>
</dl>
</li>
</ul>
<a name="pennPrint-java.io.PrintWriter-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>pennPrint</h4>
<pre>public&nbsp;void&nbsp;pennPrint(java.io.PrintWriter&nbsp;pw)</pre>
<div class="block">Print the tree as done in Penn Treebank merged files.
 The formatting should be exactly the same, but we don't print the
 trailing whitespace found in Penn Treebank trees.
 The basic deviation from a bracketed indented tree is to in general
 collapse the printing of adjacent preterminals onto one line of
 tags and words.  Additional complexities are that conjunctions
 (tag CC) are not collapsed in this way, and that the unlabeled
 outer brackets are collapsed onto the same line as the next
 bracket down.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>pw</code> - The tree is printed to this <code>PrintWriter</code></dd>
</dl>
</li>
</ul>
<a name="pennPrint-java.io.PrintWriter-boolean-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>pennPrint</h4>
<pre>public&nbsp;void&nbsp;pennPrint(java.io.PrintWriter&nbsp;pw,
                      boolean&nbsp;printOnlyLabelValue)</pre>
</li>
</ul>
<a name="pennPrint-java.io.PrintStream-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>pennPrint</h4>
<pre>public&nbsp;void&nbsp;pennPrint(java.io.PrintStream&nbsp;ps)</pre>
<div class="block">Print the tree as done in Penn Treebank merged files.
 The formatting should be exactly the same, but we don't print the
 trailing whitespace found in Penn Treebank trees.
 The basic deviation from a bracketed indented tree is to in general
 collapse the printing of adjacent preterminals onto one line of
 tags and words.  Additional complexities are that conjunctions
 (tag CC) are not collapsed in this way, and that the unlabeled
 outer brackets are collapsed onto the same line as the next
 bracket down.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>ps</code> - The tree is printed to this <code>PrintStream</code></dd>
</dl>
</li>
</ul>
<a name="pennPrint-java.io.PrintStream-boolean-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>pennPrint</h4>
<pre>public&nbsp;void&nbsp;pennPrint(java.io.PrintStream&nbsp;ps,
                      boolean&nbsp;printOnlyLabelValue)</pre>
</li>
</ul>
<a name="pennString--">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>pennString</h4>
<pre>public&nbsp;java.lang.String&nbsp;pennString()</pre>
<div class="block">Calls <code>pennPrint()</code> and saves output to a String</div>
<dl>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>The indent S-expression representation of a Tree</dd>
</dl>
</li>
</ul>
<a name="pennPrint--">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>pennPrint</h4>
<pre>public&nbsp;void&nbsp;pennPrint()</pre>
<div class="block">Print the tree as done in Penn Treebank merged files.
 The formatting should be exactly the same, but we don't print the
 trailing whitespace found in Penn Treebank trees.
 The tree is printed to <code>System.out</code>. The basic deviation
 from a bracketed indented tree is to in general
 collapse the printing of adjacent preterminals onto one line of
 tags and words.  Additional complexities are that conjunctions
 (tag CC) are not collapsed in this way, and that the unlabeled
 outer brackets are collapsed onto the same line as the next
 bracket down.</div>
</li>
</ul>
<a name="depth--">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>depth</h4>
<pre>public&nbsp;int&nbsp;depth()</pre>
<div class="block">Finds the depth of the tree.  The depth is defined as the length
 of the longest path from this node to a leaf node.  Leaf nodes
 have depth zero.  POS tags have depth 1. Phrasal nodes have
 depth &gt;= 2.</div>
<dl>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>the depth</dd>
</dl>
</li>
</ul>
<a name="depth-edu.stanford.nlp.trees.Tree-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>depth</h4>
<pre>public&nbsp;int&nbsp;depth(<a href="../../../../edu/stanford/nlp/trees/Tree.html" title="class in edu.stanford.nlp.trees">Tree</a>&nbsp;node)</pre>
<div class="block">Finds the distance from this node to the specified node.
 return -1 if this is not an ancestor of node.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>node</code> - A subtree contained in this tree</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>the depth</dd>
</dl>
</li>
</ul>
<a name="headTerminal-edu.stanford.nlp.trees.HeadFinder-edu.stanford.nlp.trees.Tree-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>headTerminal</h4>
<pre>public&nbsp;<a href="../../../../edu/stanford/nlp/trees/Tree.html" title="class in edu.stanford.nlp.trees">Tree</a>&nbsp;headTerminal(<a href="../../../../edu/stanford/nlp/trees/HeadFinder.html" title="interface in edu.stanford.nlp.trees">HeadFinder</a>&nbsp;hf,
                         <a href="../../../../edu/stanford/nlp/trees/Tree.html" title="class in edu.stanford.nlp.trees">Tree</a>&nbsp;parent)</pre>
<div class="block">Returns the tree leaf that is the head of the tree.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>hf</code> - The head-finding algorithm to use</dd>
<dd><code>parent</code> - The parent of this tree</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>The head tree leaf if any, else <code>null</code></dd>
</dl>
</li>
</ul>
<a name="headTerminal-edu.stanford.nlp.trees.HeadFinder-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>headTerminal</h4>
<pre>public&nbsp;<a href="../../../../edu/stanford/nlp/trees/Tree.html" title="class in edu.stanford.nlp.trees">Tree</a>&nbsp;headTerminal(<a href="../../../../edu/stanford/nlp/trees/HeadFinder.html" title="interface in edu.stanford.nlp.trees">HeadFinder</a>&nbsp;hf)</pre>
<div class="block">Returns the tree leaf that is the head of the tree.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>hf</code> - The headfinding algorithm to use</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>The head tree leaf if any, else <code>null</code></dd>
</dl>
</li>
</ul>
<a name="headPreTerminal-edu.stanford.nlp.trees.HeadFinder-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>headPreTerminal</h4>
<pre>public&nbsp;<a href="../../../../edu/stanford/nlp/trees/Tree.html" title="class in edu.stanford.nlp.trees">Tree</a>&nbsp;headPreTerminal(<a href="../../../../edu/stanford/nlp/trees/HeadFinder.html" title="interface in edu.stanford.nlp.trees">HeadFinder</a>&nbsp;hf)</pre>
<div class="block">Returns the preterminal tree that is the head of the tree.
 See <a href="../../../../edu/stanford/nlp/trees/Tree.html#isPreTerminal--"><code>isPreTerminal()</code></a> for
 the definition of a preterminal node. Beware that some tree nodes may
 have no preterminal head.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>hf</code> - The headfinding algorithm to use</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>The head preterminal tree, if any, else <code>null</code></dd>
<dt><span class="throwsLabel">Throws:</span></dt>
<dd><code>java.lang.IllegalArgumentException</code> - if called on a leaf node</dd>
</dl>
</li>
</ul>
<a name="percolateHeadAnnotations-edu.stanford.nlp.trees.HeadFinder-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>percolateHeadAnnotations</h4>
<pre>public&nbsp;void&nbsp;percolateHeadAnnotations(<a href="../../../../edu/stanford/nlp/trees/HeadFinder.html" title="interface in edu.stanford.nlp.trees">HeadFinder</a>&nbsp;hf)</pre>
<div class="block">Finds the head words of each tree and assigns
 HeadWordLabelAnnotation on each node pointing to the correct
 CoreLabel.  This relies on the nodes being CoreLabels, so it
 throws an IllegalArgumentException if this is ever not true.</div>
</li>
</ul>
<a name="percolateHeads-edu.stanford.nlp.trees.HeadFinder-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>percolateHeads</h4>
<pre>public&nbsp;void&nbsp;percolateHeads(<a href="../../../../edu/stanford/nlp/trees/HeadFinder.html" title="interface in edu.stanford.nlp.trees">HeadFinder</a>&nbsp;hf)</pre>
<div class="block">Finds the heads of the tree.  This code assumes that the label
 does store and return sensible values for the category, word, and tag.
 It will be a no-op otherwise.  The tree is modified.  The routine
 assumes the Tree has word leaves and tag preterminals, and copies
 their category to word and tag respectively, if they have a null
 value.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>hf</code> - The headfinding algorithm to use</dd>
</dl>
</li>
</ul>
<a name="dependencies--">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>dependencies</h4>
<pre>public&nbsp;java.util.Set&lt;<a href="../../../../edu/stanford/nlp/trees/Dependency.html" title="interface in edu.stanford.nlp.trees">Dependency</a>&lt;<a href="../../../../edu/stanford/nlp/ling/Label.html" title="interface in edu.stanford.nlp.ling">Label</a>,<a href="../../../../edu/stanford/nlp/ling/Label.html" title="interface in edu.stanford.nlp.ling">Label</a>,java.lang.Object&gt;&gt;&nbsp;dependencies()</pre>
<div class="block">Return a Set of TaggedWord-TaggedWord dependencies, represented as
 Dependency objects, for the Tree.  This will only give
 useful results if the internal tree node labels support HasWord and
 HasTag, and head percolation has already been done (see
 percolateHeads()).</div>
<dl>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>Set of dependencies (each a Dependency)</dd>
</dl>
</li>
</ul>
<a name="dependencies-java.util.function.Predicate-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>dependencies</h4>
<pre>public&nbsp;java.util.Set&lt;<a href="../../../../edu/stanford/nlp/trees/Dependency.html" title="interface in edu.stanford.nlp.trees">Dependency</a>&lt;<a href="../../../../edu/stanford/nlp/ling/Label.html" title="interface in edu.stanford.nlp.ling">Label</a>,<a href="../../../../edu/stanford/nlp/ling/Label.html" title="interface in edu.stanford.nlp.ling">Label</a>,java.lang.Object&gt;&gt;&nbsp;dependencies(java.util.function.Predicate&lt;<a href="../../../../edu/stanford/nlp/trees/Dependency.html" title="interface in edu.stanford.nlp.trees">Dependency</a>&lt;<a href="../../../../edu/stanford/nlp/ling/Label.html" title="interface in edu.stanford.nlp.ling">Label</a>,<a href="../../../../edu/stanford/nlp/ling/Label.html" title="interface in edu.stanford.nlp.ling">Label</a>,java.lang.Object&gt;&gt;&nbsp;f)</pre>
</li>
</ul>
<a name="dependencies-java.util.function.Predicate-boolean-boolean-boolean-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>dependencies</h4>
<pre>public&nbsp;java.util.Set&lt;<a href="../../../../edu/stanford/nlp/trees/Dependency.html" title="interface in edu.stanford.nlp.trees">Dependency</a>&lt;<a href="../../../../edu/stanford/nlp/ling/Label.html" title="interface in edu.stanford.nlp.ling">Label</a>,<a href="../../../../edu/stanford/nlp/ling/Label.html" title="interface in edu.stanford.nlp.ling">Label</a>,java.lang.Object&gt;&gt;&nbsp;dependencies(java.util.function.Predicate&lt;<a href="../../../../edu/stanford/nlp/trees/Dependency.html" title="interface in edu.stanford.nlp.trees">Dependency</a>&lt;<a href="../../../../edu/stanford/nlp/ling/Label.html" title="interface in edu.stanford.nlp.ling">Label</a>,<a href="../../../../edu/stanford/nlp/ling/Label.html" title="interface in edu.stanford.nlp.ling">Label</a>,java.lang.Object&gt;&gt;&nbsp;f,
                                                                            boolean&nbsp;isConcrete,
                                                                            boolean&nbsp;copyLabel,
                                                                            boolean&nbsp;copyPosTag)</pre>
<div class="block">Return a set of TaggedWord-TaggedWord dependencies, represented as
 Dependency objects, for the Tree.  This will only give
 useful results if the internal tree node labels support HasWord and
 head percolation has already been done (see percolateHeads()).</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>f</code> - Dependencies are excluded for which the Dependency is not
          accepted by the Filter</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>Set of dependencies (each a Dependency)</dd>
</dl>
</li>
</ul>
<a name="mapDependencies-java.util.function.Predicate-edu.stanford.nlp.trees.HeadFinder-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>mapDependencies</h4>
<pre>public&nbsp;java.util.Set&lt;<a href="../../../../edu/stanford/nlp/trees/Dependency.html" title="interface in edu.stanford.nlp.trees">Dependency</a>&lt;<a href="../../../../edu/stanford/nlp/ling/Label.html" title="interface in edu.stanford.nlp.ling">Label</a>,<a href="../../../../edu/stanford/nlp/ling/Label.html" title="interface in edu.stanford.nlp.ling">Label</a>,java.lang.Object&gt;&gt;&nbsp;mapDependencies(java.util.function.Predicate&lt;<a href="../../../../edu/stanford/nlp/trees/Dependency.html" title="interface in edu.stanford.nlp.trees">Dependency</a>&lt;<a href="../../../../edu/stanford/nlp/ling/Label.html" title="interface in edu.stanford.nlp.ling">Label</a>,<a href="../../../../edu/stanford/nlp/ling/Label.html" title="interface in edu.stanford.nlp.ling">Label</a>,java.lang.Object&gt;&gt;&nbsp;f,
                                                                               <a href="../../../../edu/stanford/nlp/trees/HeadFinder.html" title="interface in edu.stanford.nlp.trees">HeadFinder</a>&nbsp;hf)</pre>
<div class="block">Return a set of Label-Label dependencies, represented as
 Dependency objects, for the Tree.  The Labels are the ones of the leaf
 nodes of the tree, without mucking with them.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>f</code> - Dependencies are excluded for which the Dependency is not
           accepted by the Filter</dd>
<dd><code>hf</code> - The HeadFinder to use to identify the head of constituents.
           The code assumes
           that it can use <code>headPreTerminal(hf)</code> to find a
           tag and word to make a CoreLabel.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>Set of dependencies (each a <code>Dependency</code> between two
           <code>CoreLabel</code>s, which each contain a tag(), word(),
           and value(), the last two of which are identical).</dd>
</dl>
</li>
</ul>
<a name="mapDependencies-java.util.function.Predicate-edu.stanford.nlp.trees.HeadFinder-java.lang.String-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>mapDependencies</h4>
<pre>public&nbsp;java.util.Set&lt;<a href="../../../../edu/stanford/nlp/trees/Dependency.html" title="interface in edu.stanford.nlp.trees">Dependency</a>&lt;<a href="../../../../edu/stanford/nlp/ling/Label.html" title="interface in edu.stanford.nlp.ling">Label</a>,<a href="../../../../edu/stanford/nlp/ling/Label.html" title="interface in edu.stanford.nlp.ling">Label</a>,java.lang.Object&gt;&gt;&nbsp;mapDependencies(java.util.function.Predicate&lt;<a href="../../../../edu/stanford/nlp/trees/Dependency.html" title="interface in edu.stanford.nlp.trees">Dependency</a>&lt;<a href="../../../../edu/stanford/nlp/ling/Label.html" title="interface in edu.stanford.nlp.ling">Label</a>,<a href="../../../../edu/stanford/nlp/ling/Label.html" title="interface in edu.stanford.nlp.ling">Label</a>,java.lang.Object&gt;&gt;&nbsp;f,
                                                                               <a href="../../../../edu/stanford/nlp/trees/HeadFinder.html" title="interface in edu.stanford.nlp.trees">HeadFinder</a>&nbsp;hf,
                                                                               java.lang.String&nbsp;rootName)</pre>
<div class="block">Return a set of Label-Label dependencies, represented as
 Dependency objects, for the Tree.  The Labels are the ones of the leaf
 nodes of the tree, without mucking with them. The head of the sentence is a
 dependent of a synthetic "root" label.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>f</code> - Dependencies are excluded for which the Dependency is not
           accepted by the Filter</dd>
<dd><code>hf</code> - The HeadFinder to use to identify the head of constituents.
           The code assumes
           that it can use <code>headPreTerminal(hf)</code> to find a
           tag and word to make a CoreLabel.</dd>
<dd><code>rootName</code> - Name of the root node.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>Set of dependencies (each a <code>Dependency</code> between two
           <code>CoreLabel</code>s, which each contain a tag(), word(),
           and value(), the last two of which are identical).</dd>
</dl>
</li>
</ul>
<a name="yield--">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>yield</h4>
<pre>public&nbsp;java.util.ArrayList&lt;<a href="../../../../edu/stanford/nlp/ling/Label.html" title="interface in edu.stanford.nlp.ling">Label</a>&gt;&nbsp;yield()</pre>
<div class="block">Gets the yield of the tree.  The <code>Label</code> of all leaf nodes
 is returned
 as a list ordered by the natural left to right order of the
 leaves.  Null values, if any, are inserted into the list like any
 other value.</div>
<dl>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>a <code>List</code> of the data in the tree's leaves.</dd>
</dl>
</li>
</ul>
<a name="yield-java.util.ArrayList-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>yield</h4>
<pre>public&nbsp;java.util.ArrayList&lt;<a href="../../../../edu/stanford/nlp/ling/Label.html" title="interface in edu.stanford.nlp.ling">Label</a>&gt;&nbsp;yield(java.util.ArrayList&lt;<a href="../../../../edu/stanford/nlp/ling/Label.html" title="interface in edu.stanford.nlp.ling">Label</a>&gt;&nbsp;y)</pre>
<div class="block">Gets the yield of the tree.  The <code>Label</code> of all leaf nodes
 is returned
 as a list ordered by the natural left to right order of the
 leaves.  Null values, if any, are inserted into the list like any
 other value.
 <p><i>Implementation notes:</i> c. 2003: This has been rewritten to thread, so only one List
 is used. 2007: This method was duplicated to start to give type safety to Sentence.
 This method will now make a Word for any Leaf which does not itself implement HasWord, and
 put the Word into the Sentence, so the Sentence elements MUST implement HasWord.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>y</code> - The list in which the yield of the tree will be placed.
          Normally, this will be empty when the routine is called, but
          if not, the new yield is added to the end of the list.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>a <code>List</code> of the data in the tree's leaves.</dd>
</dl>
</li>
</ul>
<a name="yieldWords--">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>yieldWords</h4>
<pre>public&nbsp;java.util.ArrayList&lt;<a href="../../../../edu/stanford/nlp/ling/Word.html" title="class in edu.stanford.nlp.ling">Word</a>&gt;&nbsp;yieldWords()</pre>
</li>
</ul>
<a name="yieldWords-java.util.ArrayList-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>yieldWords</h4>
<pre>public&nbsp;java.util.ArrayList&lt;<a href="../../../../edu/stanford/nlp/ling/Word.html" title="class in edu.stanford.nlp.ling">Word</a>&gt;&nbsp;yieldWords(java.util.ArrayList&lt;<a href="../../../../edu/stanford/nlp/ling/Word.html" title="class in edu.stanford.nlp.ling">Word</a>&gt;&nbsp;y)</pre>
</li>
</ul>
<a name="yieldHasWord--">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>yieldHasWord</h4>
<pre>public&nbsp;&lt;X extends <a href="../../../../edu/stanford/nlp/ling/HasWord.html" title="interface in edu.stanford.nlp.ling">HasWord</a>&gt;&nbsp;java.util.ArrayList&lt;X&gt;&nbsp;yieldHasWord()</pre>
</li>
</ul>
<a name="yieldHasWord-java.util.ArrayList-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>yieldHasWord</h4>
<pre>public&nbsp;&lt;X extends <a href="../../../../edu/stanford/nlp/ling/HasWord.html" title="interface in edu.stanford.nlp.ling">HasWord</a>&gt;&nbsp;java.util.ArrayList&lt;X&gt;&nbsp;yieldHasWord(java.util.ArrayList&lt;X&gt;&nbsp;y)</pre>
</li>
</ul>
<a name="yield-java.util.List-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>yield</h4>
<pre>public&nbsp;&lt;T&gt;&nbsp;java.util.List&lt;T&gt;&nbsp;yield(java.util.List&lt;T&gt;&nbsp;y)</pre>
<div class="block">Gets the yield of the tree.  The <code>Label</code> of all leaf nodes
 is returned
 as a list ordered by the natural left to right order of the
 leaves.  Null values, if any, are inserted into the list like any
 other value.  This has been rewritten to thread, so only one List
 is used.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>y</code> - The list in which the yield of the tree will be placed.
          Normally, this will be empty when the routine is called, but
          if not, the new yield is added to the end of the list.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>a <code>List</code> of the data in the tree's leaves.</dd>
</dl>
</li>
</ul>
<a name="taggedYield--">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>taggedYield</h4>
<pre>public&nbsp;java.util.ArrayList&lt;<a href="../../../../edu/stanford/nlp/ling/TaggedWord.html" title="class in edu.stanford.nlp.ling">TaggedWord</a>&gt;&nbsp;taggedYield()</pre>
<div class="block">Gets the tagged yield of the tree.
 The <code>Label</code> of all leaf nodes is returned
 as a list ordered by the natural left to right order of the
 leaves.  Null values, if any, are inserted into the list like any
 other value.</div>
<dl>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>a <code>List</code> of the data in the tree's leaves.</dd>
</dl>
</li>
</ul>
<a name="labeledYield--">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>labeledYield</h4>
<pre>public&nbsp;java.util.List&lt;<a href="../../../../edu/stanford/nlp/ling/LabeledWord.html" title="class in edu.stanford.nlp.ling">LabeledWord</a>&gt;&nbsp;labeledYield()</pre>
</li>
</ul>
<a name="taggedYield-java.util.List-">
<!--   -->
</a><a name="taggedYield-X-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>taggedYield</h4>
<pre>public&nbsp;&lt;X extends java.util.List&lt;<a href="../../../../edu/stanford/nlp/ling/TaggedWord.html" title="class in edu.stanford.nlp.ling">TaggedWord</a>&gt;&gt;&nbsp;X&nbsp;taggedYield(X&nbsp;ty)</pre>
<div class="block">Gets the tagged yield of the tree -- that is, get the preterminals
 as well as the terminals.  The <code>Label</code> of all leaf nodes
 is returned
 as a list ordered by the natural left to right order of the
 leaves.  Null values, if any, are inserted into the list like any
 other value.  This has been rewritten to thread, so only one List
 is used.
 <p/>
 <i>Implementation note:</i> when we summon up enough courage, this
 method will be changed to take and return a <code>List&lt;W extends TaggedWord&gt;</code>.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>ty</code> - The list in which the tagged yield of the tree will be
           placed. Normally, this will be empty when the routine is called,
           but if not, the new yield is added to the end of the list.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>a <code>List</code> of the data in the tree's leaves.</dd>
</dl>
</li>
</ul>
<a name="labeledYield-java.util.List-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>labeledYield</h4>
<pre>public&nbsp;java.util.List&lt;<a href="../../../../edu/stanford/nlp/ling/LabeledWord.html" title="class in edu.stanford.nlp.ling">LabeledWord</a>&gt;&nbsp;labeledYield(java.util.List&lt;<a href="../../../../edu/stanford/nlp/ling/LabeledWord.html" title="class in edu.stanford.nlp.ling">LabeledWord</a>&gt;&nbsp;ty)</pre>
</li>
</ul>
<a name="taggedLabeledYield--">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>taggedLabeledYield</h4>
<pre>public&nbsp;java.util.List&lt;<a href="../../../../edu/stanford/nlp/ling/CoreLabel.html" title="class in edu.stanford.nlp.ling">CoreLabel</a>&gt;&nbsp;taggedLabeledYield()</pre>
<div class="block">Returns a <code>List&lt;CoreLabel&gt;</code> from the tree.
  These are a copy of the complete token representation
  that adds the tag as the tag and value.</div>
<dl>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>A tagged, labeled yield.</dd>
</dl>
</li>
</ul>
<a name="preTerminalYield--">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>preTerminalYield</h4>
<pre>public&nbsp;java.util.List&lt;<a href="../../../../edu/stanford/nlp/ling/Label.html" title="interface in edu.stanford.nlp.ling">Label</a>&gt;&nbsp;preTerminalYield()</pre>
<div class="block">Gets the preterminal yield (i.e., tags) of the tree.  All data in
 preterminal nodes is returned as a list ordered by the natural left to
 right order of the tree.  Null values, if any, are inserted into the
 list like any other value.  Pre-leaves are nodes of height 1.</div>
<dl>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>a <code>List</code> of the data in the tree's pre-leaves.</dd>
</dl>
</li>
</ul>
<a name="preTerminalYield-java.util.List-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>preTerminalYield</h4>
<pre>public&nbsp;java.util.List&lt;<a href="../../../../edu/stanford/nlp/ling/Label.html" title="interface in edu.stanford.nlp.ling">Label</a>&gt;&nbsp;preTerminalYield(java.util.List&lt;<a href="../../../../edu/stanford/nlp/ling/Label.html" title="interface in edu.stanford.nlp.ling">Label</a>&gt;&nbsp;y)</pre>
<div class="block">Gets the preterminal yield (i.e., tags) of the tree.  All data in
 preleaf nodes is returned as a list ordered by the natural left to
 right order of the tree.  Null values, if any, are inserted into the
 list like any other value.  Pre-leaves are nodes of height 1.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>y</code> - The list in which the preterminals of the tree will be
          placed. Normally, this will be empty when the routine is called,
          but if not, the new yield is added to the end of the list.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>a <code>List</code> of the data in the tree's pre-leaves.</dd>
</dl>
</li>
</ul>
<a name="getLeaves--">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>getLeaves</h4>
<pre>public&nbsp;&lt;T extends <a href="../../../../edu/stanford/nlp/trees/Tree.html" title="class in edu.stanford.nlp.trees">Tree</a>&gt;&nbsp;java.util.List&lt;T&gt;&nbsp;getLeaves()</pre>
<div class="block">Gets the leaves of the tree.  All leaves nodes are returned as a list
 ordered by the natural left to right order of the tree.  Null values,
 if any, are inserted into the list like any other value.</div>
<dl>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>a <code>List</code> of the leaves.</dd>
</dl>
</li>
</ul>
<a name="getLeaves-java.util.List-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>getLeaves</h4>
<pre>public&nbsp;&lt;T extends <a href="../../../../edu/stanford/nlp/trees/Tree.html" title="class in edu.stanford.nlp.trees">Tree</a>&gt;&nbsp;java.util.List&lt;T&gt;&nbsp;getLeaves(java.util.List&lt;T&gt;&nbsp;list)</pre>
<div class="block">Gets the leaves of the tree.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>list</code> - The list in which the leaves of the tree will be
             placed. Normally, this will be empty when the routine is called,
             but if not, the new yield is added to the end of the list.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>a <code>List</code> of the leaves.</dd>
</dl>
</li>
</ul>
<a name="labels--">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>labels</h4>
<pre>public&nbsp;java.util.Collection&lt;<a href="../../../../edu/stanford/nlp/ling/Label.html" title="interface in edu.stanford.nlp.ling">Label</a>&gt;&nbsp;labels()</pre>
<div class="block">Get the set of all node and leaf <code>Label</code>s,
 null or otherwise, contained in the tree.</div>
<dl>
<dt><span class="overrideSpecifyLabel">Specified by:</span></dt>
<dd><code><a href="../../../../edu/stanford/nlp/trees/Labeled.html#labels--">labels</a></code>&nbsp;in interface&nbsp;<code><a href="../../../../edu/stanford/nlp/trees/Labeled.html" title="interface in edu.stanford.nlp.trees">Labeled</a></code></dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>the <code>Collection</code> (actually, Set) of all values
         in the tree.</dd>
</dl>
</li>
</ul>
<a name="setLabels-java.util.Collection-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>setLabels</h4>
<pre>public&nbsp;void&nbsp;setLabels(java.util.Collection&lt;<a href="../../../../edu/stanford/nlp/ling/Label.html" title="interface in edu.stanford.nlp.ling">Label</a>&gt;&nbsp;c)</pre>
<div class="block"><span class="descfrmTypeLabel">Description copied from interface:&nbsp;<code><a href="../../../../edu/stanford/nlp/trees/Labeled.html#setLabels-java.util.Collection-">Labeled</a></code></span></div>
<div class="block">Sets the labels associated with this object.</div>
<dl>
<dt><span class="overrideSpecifyLabel">Specified by:</span></dt>
<dd><code><a href="../../../../edu/stanford/nlp/trees/Labeled.html#setLabels-java.util.Collection-">setLabels</a></code>&nbsp;in interface&nbsp;<code><a href="../../../../edu/stanford/nlp/trees/Labeled.html" title="interface in edu.stanford.nlp.trees">Labeled</a></code></dd>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>c</code> - The set of Label values</dd>
</dl>
</li>
</ul>
<a name="flatten--">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>flatten</h4>
<pre>public&nbsp;<a href="../../../../edu/stanford/nlp/trees/Tree.html" title="class in edu.stanford.nlp.trees">Tree</a>&nbsp;flatten()</pre>
<div class="block">Return a flattened version of a tree.  In many circumstances, this
 will just return the tree, but if the tree is something like a
 binarized version of a dependency grammar tree, then it will be
 flattened back to a dependency grammar tree representation.  Formally,
 a node will be removed from the tree when: it is not a terminal or
 preterminal, and its <code>label()</code is <code>equal()</code> to
 the <code>label()</code> of its parent, and all its children will
 then be promoted to become children of the parent (in the same
 position in the sequence of daughters.</div>
<dl>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>A flattened version of this tree.</dd>
</dl>
</li>
</ul>
<a name="flatten-edu.stanford.nlp.trees.TreeFactory-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>flatten</h4>
<pre>public&nbsp;<a href="../../../../edu/stanford/nlp/trees/Tree.html" title="class in edu.stanford.nlp.trees">Tree</a>&nbsp;flatten(<a href="../../../../edu/stanford/nlp/trees/TreeFactory.html" title="interface in edu.stanford.nlp.trees">TreeFactory</a>&nbsp;tf)</pre>
<div class="block">Return a flattened version of a tree.  In many circumstances, this
 will just return the tree, but if the tree is something like a
 binarized version of a dependency grammar tree, then it will be
 flattened back to a dependency grammar tree representation.  Formally,
 a node will be removed from the tree when: it is not a terminal or
 preterminal, and its <code>label()</code is <code>equal()</code> to
 the <code>label()</code> of its parent, and all its children will
 then be promoted to become children of the parent (in the same
 position in the sequence of daughters. <p>
 Note: In the current implementation, the tree structure is mainly
 duplicated, but the links between preterminals and terminals aren't.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>tf</code> - TreeFactory used to create tree structure for flattened tree</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>A flattened version of this tree.</dd>
</dl>
</li>
</ul>
<a name="subTrees--">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>subTrees</h4>
<pre>public&nbsp;java.util.Set&lt;<a href="../../../../edu/stanford/nlp/trees/Tree.html" title="class in edu.stanford.nlp.trees">Tree</a>&gt;&nbsp;subTrees()</pre>
<div class="block">Get the set of all subtrees inside the tree by returning a tree
 rooted at each node.  These are <i>not</i> copies, but all share
 structure.  The tree is regarded as a subtree of itself.
 <p/>
 <i>Note:</i> If you only want to form this Set so that you can
 iterate over it, it is more efficient to simply use the Tree class's
 own <code>iterator() method. This will iterate over the exact same
 elements (but perhaps/probably in a different order).</div>
<dl>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>the <code>Set</code> of all subtrees in the tree.</dd>
</dl>
</li>
</ul>
<a name="subTreeList--">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>subTreeList</h4>
<pre>public&nbsp;java.util.List&lt;<a href="../../../../edu/stanford/nlp/trees/Tree.html" title="class in edu.stanford.nlp.trees">Tree</a>&gt;&nbsp;subTreeList()</pre>
<div class="block">Get the list of all subtrees inside the tree by returning a tree
 rooted at each node.  These are <i>not</i> copies, but all share
 structure.  The tree is regarded as a subtree of itself.
 <p/>
 <i>Note:</i> If you only want to form this Collection so that you can
 iterate over it, it is more efficient to simply use the Tree class's
 own <code>iterator() method. This will iterate over the exact same
 elements (but perhaps/probably in a different order).</div>
<dl>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>the <code>List</code> of all subtrees in the tree.</dd>
</dl>
</li>
</ul>
<a name="subTrees-java.util.Collection-">
<!--   -->
</a><a name="subTrees-T-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>subTrees</h4>
<pre>public&nbsp;&lt;T extends java.util.Collection&lt;<a href="../../../../edu/stanford/nlp/trees/Tree.html" title="class in edu.stanford.nlp.trees">Tree</a>&gt;&gt;&nbsp;T&nbsp;subTrees(T&nbsp;n)</pre>
<div class="block">Add the set of all subtrees inside a tree (including the tree itself)
 to the given <code>Collection</code>.
 <p/>
 <i>Note:</i> If you only want to form this Collection so that you can
 iterate over it, it is more efficient to simply use the Tree class's
 own <code>iterator() method. This will iterate over the exact same
 elements (but perhaps/probably in a different order).</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>n</code> - A collection of nodes to which the subtrees will be added.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>The collection parameter with the subtrees added.</dd>
</dl>
</li>
</ul>
<a name="deepCopy--">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>deepCopy</h4>
<pre>public&nbsp;<a href="../../../../edu/stanford/nlp/trees/Tree.html" title="class in edu.stanford.nlp.trees">Tree</a>&nbsp;deepCopy()</pre>
<div class="block">Makes a deep copy of not only the Tree structure but of the labels as well.
 Uses the TreeFactory of the root node given by treeFactory().
 Assumes that your labels give a non-null labelFactory().
 (Added by Aria Haghighi.)</div>
<dl>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>A deep copy of the tree structure and its labels</dd>
</dl>
</li>
</ul>
<a name="deepCopy-edu.stanford.nlp.trees.TreeFactory-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>deepCopy</h4>
<pre>public&nbsp;<a href="../../../../edu/stanford/nlp/trees/Tree.html" title="class in edu.stanford.nlp.trees">Tree</a>&nbsp;deepCopy(<a href="../../../../edu/stanford/nlp/trees/TreeFactory.html" title="interface in edu.stanford.nlp.trees">TreeFactory</a>&nbsp;tf)</pre>
<div class="block">Makes a deep copy of not only the Tree structure but of the labels as well.
 The new tree will have nodes made by the given TreeFactory.
 Each Label is copied using the labelFactory() returned
 by the corresponding node's label.
 It assumes that your labels give non-null labelFactory.
 (Added by Aria Haghighi.)</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>tf</code> - The TreeFactory used to make all nodes in the copied
           tree structure</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>A Tree that is a deep copy of the tree structure and
         Labels of the original tree.</dd>
</dl>
</li>
</ul>
<a name="deepCopy-edu.stanford.nlp.trees.TreeFactory-edu.stanford.nlp.ling.LabelFactory-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>deepCopy</h4>
<pre>public&nbsp;<a href="../../../../edu/stanford/nlp/trees/Tree.html" title="class in edu.stanford.nlp.trees">Tree</a>&nbsp;deepCopy(<a href="../../../../edu/stanford/nlp/trees/TreeFactory.html" title="interface in edu.stanford.nlp.trees">TreeFactory</a>&nbsp;tf,
                     <a href="../../../../edu/stanford/nlp/ling/LabelFactory.html" title="interface in edu.stanford.nlp.ling">LabelFactory</a>&nbsp;lf)</pre>
<div class="block">Makes a deep copy of not only the Tree structure but of the labels as well.
 Each tree is copied with the given TreeFactory.
 Each Label is copied using the given LabelFactory.
 That is, the tree and label factories can transform the nature of the
 data representation.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>tf</code> - The TreeFactory used to make all nodes in the copied
           tree structure</dd>
<dd><code>lf</code> - The LabelFactory used to make all nodes in the copied
           tree structure</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>A Tree that is a deep copy of the tree structure and
         Labels of the original tree.</dd>
</dl>
</li>
</ul>
<a name="treeSkeletonCopy--">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>treeSkeletonCopy</h4>
<pre>public&nbsp;<a href="../../../../edu/stanford/nlp/trees/Tree.html" title="class in edu.stanford.nlp.trees">Tree</a>&nbsp;treeSkeletonCopy()</pre>
<div class="block">Create a deep copy of the tree structure.  The entire structure is
 recursively copied, but label data themselves are not cloned.
 The copy is built using a <code>TreeFactory</code> that will
 produce a <code>Tree</code> like the input one.</div>
<dl>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>A deep copy of the tree structure (but not its labels).</dd>
</dl>
</li>
</ul>
<a name="treeSkeletonCopy-edu.stanford.nlp.trees.TreeFactory-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>treeSkeletonCopy</h4>
<pre>public&nbsp;<a href="../../../../edu/stanford/nlp/trees/Tree.html" title="class in edu.stanford.nlp.trees">Tree</a>&nbsp;treeSkeletonCopy(<a href="../../../../edu/stanford/nlp/trees/TreeFactory.html" title="interface in edu.stanford.nlp.trees">TreeFactory</a>&nbsp;tf)</pre>
<div class="block">Create a deep copy of the tree structure.  The entire structure is
 recursively copied, but label data themselves are not cloned.
 By specifying an appropriate <code>TreeFactory</code>, this
 method can be used to change the type of a <code>Tree</code>.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>tf</code> - The <code>TreeFactory</code> to be used for creating
           the returned <code>Tree</code></dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>A deep copy of the tree structure (but not its labels).</dd>
</dl>
</li>
</ul>
<a name="treeSkeletonConstituentCopy--">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>treeSkeletonConstituentCopy</h4>
<pre>public&nbsp;<a href="../../../../edu/stanford/nlp/trees/Tree.html" title="class in edu.stanford.nlp.trees">Tree</a>&nbsp;treeSkeletonConstituentCopy()</pre>
<div class="block">Returns a deep copy of everything but the leaf labels.  The leaf
 labels are reused from the original tree.  This is useful for
 cases such as the dependency converter, which wants to finish
 with the same labels in the dependencies as the parse tree.</div>
</li>
</ul>
<a name="treeSkeletonConstituentCopy-edu.stanford.nlp.trees.TreeFactory-edu.stanford.nlp.ling.LabelFactory-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>treeSkeletonConstituentCopy</h4>
<pre>public&nbsp;<a href="../../../../edu/stanford/nlp/trees/Tree.html" title="class in edu.stanford.nlp.trees">Tree</a>&nbsp;treeSkeletonConstituentCopy(<a href="../../../../edu/stanford/nlp/trees/TreeFactory.html" title="interface in edu.stanford.nlp.trees">TreeFactory</a>&nbsp;tf,
                                        <a href="../../../../edu/stanford/nlp/ling/LabelFactory.html" title="interface in edu.stanford.nlp.ling">LabelFactory</a>&nbsp;lf)</pre>
</li>
</ul>
<a name="transform-edu.stanford.nlp.trees.TreeTransformer-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>transform</h4>
<pre>public&nbsp;<a href="../../../../edu/stanford/nlp/trees/Tree.html" title="class in edu.stanford.nlp.trees">Tree</a>&nbsp;transform(<a href="../../../../edu/stanford/nlp/trees/TreeTransformer.html" title="interface in edu.stanford.nlp.trees">TreeTransformer</a>&nbsp;transformer)</pre>
<div class="block">Create a transformed Tree.  The tree is traversed in a depth-first,
 left-to-right order, and the <code>TreeTransformer</code> is called
 on each node.  It returns some <code>Tree</code>.  The transformed
 tree has a new tree structure (i.e., a "deep copy" is done), but it
 will usually share its labels with the original tree.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>transformer</code> - The function that transforms tree nodes or subtrees</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>a transformation of this <code>Tree</code></dd>
</dl>
</li>
</ul>
<a name="transform-edu.stanford.nlp.trees.TreeTransformer-edu.stanford.nlp.trees.TreeFactory-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>transform</h4>
<pre>public&nbsp;<a href="../../../../edu/stanford/nlp/trees/Tree.html" title="class in edu.stanford.nlp.trees">Tree</a>&nbsp;transform(<a href="../../../../edu/stanford/nlp/trees/TreeTransformer.html" title="interface in edu.stanford.nlp.trees">TreeTransformer</a>&nbsp;transformer,
                      <a href="../../../../edu/stanford/nlp/trees/TreeFactory.html" title="interface in edu.stanford.nlp.trees">TreeFactory</a>&nbsp;tf)</pre>
<div class="block">Create a transformed Tree.  The tree is traversed in a depth-first,
 left-to-right order, and the <code>TreeTransformer</code> is called
 on each node.  It returns some <code>Tree</code>.  The transformed
 tree has a new tree structure (i.e., a deep copy of the structure of the tree is done), but it
 will usually share its labels with the original tree.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>transformer</code> - The function that transforms tree nodes or subtrees</dd>
<dd><code>tf</code> - The <code>TreeFactory</code> which will be used for creating
                    new nodes for the returned <code>Tree</code></dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>a transformation of this <code>Tree</code></dd>
</dl>
</li>
</ul>
<a name="spliceOut-java.util.function.Predicate-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>spliceOut</h4>
<pre>public&nbsp;<a href="../../../../edu/stanford/nlp/trees/Tree.html" title="class in edu.stanford.nlp.trees">Tree</a>&nbsp;spliceOut(java.util.function.Predicate&lt;<a href="../../../../edu/stanford/nlp/trees/Tree.html" title="class in edu.stanford.nlp.trees">Tree</a>&gt;&nbsp;nodeFilter)</pre>
<div class="block">Creates a (partial) deep copy of the tree, where all nodes that the
 filter does not accept are spliced out.  If the result is not a tree
 (that is, it's a forest), an empty root node is generated.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>nodeFilter</code> - a Filter method which returns true to mean
                   keep this node, false to mean delete it</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>a filtered copy of the tree</dd>
</dl>
</li>
</ul>
<a name="spliceOut-java.util.function.Predicate-edu.stanford.nlp.trees.TreeFactory-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>spliceOut</h4>
<pre>public&nbsp;<a href="../../../../edu/stanford/nlp/trees/Tree.html" title="class in edu.stanford.nlp.trees">Tree</a>&nbsp;spliceOut(java.util.function.Predicate&lt;<a href="../../../../edu/stanford/nlp/trees/Tree.html" title="class in edu.stanford.nlp.trees">Tree</a>&gt;&nbsp;nodeFilter,
                      <a href="../../../../edu/stanford/nlp/trees/TreeFactory.html" title="interface in edu.stanford.nlp.trees">TreeFactory</a>&nbsp;tf)</pre>
<div class="block">Creates a (partial) deep copy of the tree, where all nodes that the
 filter does not accept are spliced out.  That is, the particular
 modes for which the <code>Filter</code> returns <code>false</code>
 are removed from the <code>Tree</code>, but those nodes' children
 are kept (assuming they pass the <code>Filter</code>, and they are
 added in the appropriate left-to-right ordering as new children of
 the parent node.  If the root node is deleted, so that the result
 would not be a tree (that is, it's a forest), an empty root node is
 generated.  If nothing is accepted, <code>null</code> is returned.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>nodeFilter</code> - a Filter method which returns true to mean
                   keep this node, false to mean delete it</dd>
<dd><code>tf</code> - A <code>TreeFactory</code> for making new trees. Used if
                   the root node is deleted.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>a filtered copy of the tree.</dd>
</dl>
</li>
</ul>
<a name="prune-java.util.function.Predicate-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>prune</h4>
<pre>public&nbsp;<a href="../../../../edu/stanford/nlp/trees/Tree.html" title="class in edu.stanford.nlp.trees">Tree</a>&nbsp;prune(java.util.function.Predicate&lt;<a href="../../../../edu/stanford/nlp/trees/Tree.html" title="class in edu.stanford.nlp.trees">Tree</a>&gt;&nbsp;filter)</pre>
<div class="block">Creates a deep copy of the tree, where all nodes that the filter
 does not accept and all children of such nodes are pruned.  If all
 of a node's children are pruned, that node is cut as well.
 A <code>Filter</code> can assume
 that it will not be called with a <code>null</code> argument.
 <p/>
 For example, the following code excises all PP nodes from a Tree: <br>
 <tt>
 Filter<Tree> f = new Filter<Tree> { <br>
 public boolean accept(Tree t) { <br>
 return ! t.label().value().equals("PP"); <br>
 } <br>
 }; <br>
 tree.prune(f);
 </tt> <br>

 If the root of the tree is pruned, null will be returned.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>filter</code> - the filter to be applied</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>a filtered copy of the tree, including the possibility of
         <code>null</code> if the root node of the tree is filtered</dd>
</dl>
</li>
</ul>
<a name="prune-java.util.function.Predicate-edu.stanford.nlp.trees.TreeFactory-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>prune</h4>
<pre>public&nbsp;<a href="../../../../edu/stanford/nlp/trees/Tree.html" title="class in edu.stanford.nlp.trees">Tree</a>&nbsp;prune(java.util.function.Predicate&lt;<a href="../../../../edu/stanford/nlp/trees/Tree.html" title="class in edu.stanford.nlp.trees">Tree</a>&gt;&nbsp;filter,
                  <a href="../../../../edu/stanford/nlp/trees/TreeFactory.html" title="interface in edu.stanford.nlp.trees">TreeFactory</a>&nbsp;tf)</pre>
<div class="block">Creates a deep copy of the tree, where all nodes that the filter
 does not accept and all children of such nodes are pruned.  If all
 of a node's children are pruned, that node is cut as well.
 A <code>Filter</code> can assume
 that it will not be called with a <code>null</code> argument.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>filter</code> - the filter to be applied</dd>
<dd><code>tf</code> - the TreeFactory to be used to make new Tree nodes if needed</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>a filtered copy of the tree, including the possibility of
         <code>null</code> if the root node of the tree is filtered</dd>
</dl>
</li>
</ul>
<a name="skipRoot--">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>skipRoot</h4>
<pre>public&nbsp;<a href="../../../../edu/stanford/nlp/trees/Tree.html" title="class in edu.stanford.nlp.trees">Tree</a>&nbsp;skipRoot()</pre>
<div class="block">Returns first child if this is unary and if the label at the current
 node is either "ROOT" or empty.</div>
<dl>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>The first child if this is unary and if the label at the current
 node is either "ROOT" or empty, else this</dd>
</dl>
</li>
</ul>
<a name="treeFactory--">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>treeFactory</h4>
<pre>public abstract&nbsp;<a href="../../../../edu/stanford/nlp/trees/TreeFactory.html" title="interface in edu.stanford.nlp.trees">TreeFactory</a>&nbsp;treeFactory()</pre>
<div class="block">Return a <code>TreeFactory</code> that produces trees of the
 appropriate type.</div>
<dl>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>A factory to produce Trees</dd>
</dl>
</li>
</ul>
<a name="parent--">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>parent</h4>
<pre>public&nbsp;<a href="../../../../edu/stanford/nlp/trees/Tree.html" title="class in edu.stanford.nlp.trees">Tree</a>&nbsp;parent()</pre>
<div class="block">Return the parent of the tree node.  This routine may return
 <code>null</code> meaning simply that the implementation doesn't
 know how to determine the parent node, rather than there is no
 such node.</div>
<dl>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>The parent <code>Tree</code> node or <code>null</code></dd>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="../../../../edu/stanford/nlp/trees/Tree.html#parent-edu.stanford.nlp.trees.Tree-"><code>parent(Tree)</code></a></dd>
</dl>
</li>
</ul>
<a name="parent-edu.stanford.nlp.trees.Tree-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>parent</h4>
<pre>public&nbsp;<a href="../../../../edu/stanford/nlp/trees/Tree.html" title="class in edu.stanford.nlp.trees">Tree</a>&nbsp;parent(<a href="../../../../edu/stanford/nlp/trees/Tree.html" title="class in edu.stanford.nlp.trees">Tree</a>&nbsp;root)</pre>
<div class="block">Return the parent of the tree node.  This routine will traverse
 a tree (depth first) from the given <code>root</code>, and will
 correctly find the parent, regardless of whether the concrete
 class stores parents.  It will only return <code>null</code> if this
 node is the <code>root</code> node, or if this node is not
 contained within the tree rooted at <code>root</code>.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>root</code> - The root node of the whole Tree</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>the parent <code>Tree</code> node if any;
         else <code>null</code></dd>
</dl>
</li>
</ul>
<a name="size--">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>size</h4>
<pre>public&nbsp;int&nbsp;size()</pre>
<div class="block">Returns the number of nodes the tree contains.  This method
 implements the <code>size()</code> function required by the
 <code>Collections</code> interface.  The size of the tree is the
 number of nodes it contains (of all types, including the leaf nodes
 and the root).</div>
<dl>
<dt><span class="overrideSpecifyLabel">Specified by:</span></dt>
<dd><code>size</code>&nbsp;in interface&nbsp;<code>java.util.Collection&lt;<a href="../../../../edu/stanford/nlp/trees/Tree.html" title="class in edu.stanford.nlp.trees">Tree</a>&gt;</code></dd>
<dt><span class="overrideSpecifyLabel">Specified by:</span></dt>
<dd><code>size</code>&nbsp;in class&nbsp;<code>java.util.AbstractCollection&lt;<a href="../../../../edu/stanford/nlp/trees/Tree.html" title="class in edu.stanford.nlp.trees">Tree</a>&gt;</code></dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>The size of the tree</dd>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="../../../../edu/stanford/nlp/trees/Tree.html#depth--"><code>depth()</code></a></dd>
</dl>
</li>
</ul>
<a name="ancestor-int-edu.stanford.nlp.trees.Tree-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>ancestor</h4>
<pre>public&nbsp;<a href="../../../../edu/stanford/nlp/trees/Tree.html" title="class in edu.stanford.nlp.trees">Tree</a>&nbsp;ancestor(int&nbsp;height,
                     <a href="../../../../edu/stanford/nlp/trees/Tree.html" title="class in edu.stanford.nlp.trees">Tree</a>&nbsp;root)</pre>
<div class="block">Return the ancestor tree node <code>height</code> nodes up from the current node.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>height</code> - How many nodes up to go. A parameter of 0 means return
               this node, 1 means to return the parent node and so on.</dd>
<dd><code>root</code> - The root node that this Tree is embedded under</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>The ancestor at height <code>height</code>.  It returns null
         if it does not exist or the tree implementation does not keep track
         of parents</dd>
</dl>
</li>
</ul>
<a name="iterator--">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>iterator</h4>
<pre>public&nbsp;java.util.Iterator&lt;<a href="../../../../edu/stanford/nlp/trees/Tree.html" title="class in edu.stanford.nlp.trees">Tree</a>&gt;&nbsp;iterator()</pre>
<div class="block">Returns an iterator over all the nodes of the tree.  This method
 implements the <code>iterator()</code> method required by the
 <code>Collections</code> interface.  It does a preorder
 (children after node) traversal of the tree.  (A possible
 extension to the class at some point would be to allow different
 traversal orderings via variant iterators.)</div>
<dl>
<dt><span class="overrideSpecifyLabel">Specified by:</span></dt>
<dd><code>iterator</code>&nbsp;in interface&nbsp;<code>java.lang.Iterable&lt;<a href="../../../../edu/stanford/nlp/trees/Tree.html" title="class in edu.stanford.nlp.trees">Tree</a>&gt;</code></dd>
<dt><span class="overrideSpecifyLabel">Specified by:</span></dt>
<dd><code>iterator</code>&nbsp;in interface&nbsp;<code>java.util.Collection&lt;<a href="../../../../edu/stanford/nlp/trees/Tree.html" title="class in edu.stanford.nlp.trees">Tree</a>&gt;</code></dd>
<dt><span class="overrideSpecifyLabel">Specified by:</span></dt>
<dd><code>iterator</code>&nbsp;in class&nbsp;<code>java.util.AbstractCollection&lt;<a href="../../../../edu/stanford/nlp/trees/Tree.html" title="class in edu.stanford.nlp.trees">Tree</a>&gt;</code></dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>An iterator over the nodes of the tree</dd>
</dl>
</li>
</ul>
<a name="postOrderNodeList--">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>postOrderNodeList</h4>
<pre>public&nbsp;java.util.List&lt;<a href="../../../../edu/stanford/nlp/trees/Tree.html" title="class in edu.stanford.nlp.trees">Tree</a>&gt;&nbsp;postOrderNodeList()</pre>
</li>
</ul>
<a name="preOrderNodeList--">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>preOrderNodeList</h4>
<pre>public&nbsp;java.util.List&lt;<a href="../../../../edu/stanford/nlp/trees/Tree.html" title="class in edu.stanford.nlp.trees">Tree</a>&gt;&nbsp;preOrderNodeList()</pre>
</li>
</ul>
<a name="valueOf-java.lang.String-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>valueOf</h4>
<pre>public static&nbsp;<a href="../../../../edu/stanford/nlp/trees/Tree.html" title="class in edu.stanford.nlp.trees">Tree</a>&nbsp;valueOf(java.lang.String&nbsp;str)</pre>
<div class="block">This gives you a tree from a String representation (as a
 bracketed Tree, of the kind produced by <code>toString()</code>,
 <code>pennPrint()</code>, or as in the Penn Treebank).
 It's not the most efficient thing to do for heavy duty usage.
 The Tree returned is created by a
 LabeledScoredTreeReaderFactory. This means that "standard"
 normalizations (stripping functional categories, indices,
 empty nodes, and A-over-A nodes) will be done on it.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>str</code> - The tree as a bracketed list in a String.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>The Tree</dd>
<dt><span class="throwsLabel">Throws:</span></dt>
<dd><code>java.lang.RuntimeException</code> - If Tree format is not valid</dd>
</dl>
</li>
</ul>
<a name="valueOf-java.lang.String-edu.stanford.nlp.trees.TreeReaderFactory-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>valueOf</h4>
<pre>public static&nbsp;<a href="../../../../edu/stanford/nlp/trees/Tree.html" title="class in edu.stanford.nlp.trees">Tree</a>&nbsp;valueOf(java.lang.String&nbsp;str,
                           <a href="../../../../edu/stanford/nlp/trees/TreeReaderFactory.html" title="interface in edu.stanford.nlp.trees">TreeReaderFactory</a>&nbsp;trf)</pre>
<div class="block">This gives you a tree from a String representation (as a
 bracketed Tree, of the kind produced by <code>toString()</code>,
 <code>pennPrint()</code>, or as in the Penn Treebank.
 It's not the most efficient thing to do for heavy duty usage.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>str</code> - The tree as a bracketed list in a String.</dd>
<dd><code>trf</code> - The TreeFactory used to make the new Tree</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>The Tree</dd>
<dt><span class="throwsLabel">Throws:</span></dt>
<dd><code>java.lang.RuntimeException</code> - If the Tree format is not valid</dd>
</dl>
</li>
</ul>
<a name="getChild-int-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>getChild</h4>
<pre>public&nbsp;<a href="../../../../edu/stanford/nlp/trees/Tree.html" title="class in edu.stanford.nlp.trees">Tree</a>&nbsp;getChild(int&nbsp;i)</pre>
<div class="block">Return the child at some daughter index.  The children are numbered
 starting with an index of 0.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>i</code> - The daughter index</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>The tree at that daughter index</dd>
</dl>
</li>
</ul>
<a name="removeChild-int-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>removeChild</h4>
<pre>public&nbsp;<a href="../../../../edu/stanford/nlp/trees/Tree.html" title="class in edu.stanford.nlp.trees">Tree</a>&nbsp;removeChild(int&nbsp;i)</pre>
<div class="block">Destructively removes the child at some daughter index and returns it.
 Note
 that this method will throw an <code>ArrayIndexOutOfBoundsException</code> if
 the daughter index is too big for the list of daughters.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>i</code> - The daughter index</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>The tree at that daughter index</dd>
</dl>
</li>
</ul>
<a name="addChild-int-edu.stanford.nlp.trees.Tree-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>addChild</h4>
<pre>public&nbsp;void&nbsp;addChild(int&nbsp;i,
                     <a href="../../../../edu/stanford/nlp/trees/Tree.html" title="class in edu.stanford.nlp.trees">Tree</a>&nbsp;t)</pre>
<div class="block">Adds the tree t at the index position among the daughters.  Note
 that this method will throw an <code>ArrayIndexOutOfBoundsException</code> if
 the daughter index is too big for the list of daughters.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>i</code> - the index position at which to add the new daughter</dd>
<dd><code>t</code> - the new daughter</dd>
</dl>
</li>
</ul>
<a name="addChild-edu.stanford.nlp.trees.Tree-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>addChild</h4>
<pre>public&nbsp;void&nbsp;addChild(<a href="../../../../edu/stanford/nlp/trees/Tree.html" title="class in edu.stanford.nlp.trees">Tree</a>&nbsp;t)</pre>
<div class="block">Adds the tree t at the last index position among the daughters.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>t</code> - the new daughter</dd>
</dl>
</li>
</ul>
<a name="setChild-int-edu.stanford.nlp.trees.Tree-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>setChild</h4>
<pre>public&nbsp;<a href="../../../../edu/stanford/nlp/trees/Tree.html" title="class in edu.stanford.nlp.trees">Tree</a>&nbsp;setChild(int&nbsp;i,
                     <a href="../../../../edu/stanford/nlp/trees/Tree.html" title="class in edu.stanford.nlp.trees">Tree</a>&nbsp;t)</pre>
<div class="block">Replaces the <code>i</code>th child of <code>this</code> with the tree t.
 Note
 that this method will throw an <code>ArrayIndexOutOfBoundsException</code> if
 the child index is too big for the list of children.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>i</code> - The index position at which to replace the child</dd>
<dd><code>t</code> - The new child</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>The tree that was previously the ith d</dd>
</dl>
</li>
</ul>
<a name="dominates-edu.stanford.nlp.trees.Tree-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>dominates</h4>
<pre>public&nbsp;boolean&nbsp;dominates(<a href="../../../../edu/stanford/nlp/trees/Tree.html" title="class in edu.stanford.nlp.trees">Tree</a>&nbsp;t)</pre>
<div class="block">Returns true if <code>this</code> dominates the Tree passed in
 as an argument.  Object equality (==) rather than .equals() is used
 to determine domination.
 t.dominates(t) returns false.</div>
</li>
</ul>
<a name="dominationPath-edu.stanford.nlp.trees.Tree-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>dominationPath</h4>
<pre>public&nbsp;java.util.List&lt;<a href="../../../../edu/stanford/nlp/trees/Tree.html" title="class in edu.stanford.nlp.trees">Tree</a>&gt;&nbsp;dominationPath(<a href="../../../../edu/stanford/nlp/trees/Tree.html" title="class in edu.stanford.nlp.trees">Tree</a>&nbsp;t)</pre>
<div class="block">Returns the path of nodes leading down to a dominated node,
 including <code>this</code> and the dominated node itself.
 Returns null if t is not dominated by <code>this</code>.  Object
 equality (==) is the relevant criterion.
 t.dominationPath(t) returns null.</div>
</li>
</ul>
<a name="pathNodeToNode-edu.stanford.nlp.trees.Tree-edu.stanford.nlp.trees.Tree-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>pathNodeToNode</h4>
<pre>public&nbsp;java.util.List&lt;<a href="../../../../edu/stanford/nlp/trees/Tree.html" title="class in edu.stanford.nlp.trees">Tree</a>&gt;&nbsp;pathNodeToNode(<a href="../../../../edu/stanford/nlp/trees/Tree.html" title="class in edu.stanford.nlp.trees">Tree</a>&nbsp;t1,
                                           <a href="../../../../edu/stanford/nlp/trees/Tree.html" title="class in edu.stanford.nlp.trees">Tree</a>&nbsp;t2)</pre>
<div class="block">Given nodes <code>t1</code> and <code>t2</code> which are
 dominated by this node, returns a list of all the nodes on the
 path from t1 to t2, inclusive, or null if none found.</div>
</li>
</ul>
<a name="joinNode-edu.stanford.nlp.trees.Tree-edu.stanford.nlp.trees.Tree-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>joinNode</h4>
<pre>public&nbsp;<a href="../../../../edu/stanford/nlp/trees/Tree.html" title="class in edu.stanford.nlp.trees">Tree</a>&nbsp;joinNode(<a href="../../../../edu/stanford/nlp/trees/Tree.html" title="class in edu.stanford.nlp.trees">Tree</a>&nbsp;t1,
                     <a href="../../../../edu/stanford/nlp/trees/Tree.html" title="class in edu.stanford.nlp.trees">Tree</a>&nbsp;t2)</pre>
<div class="block">Given nodes <code>t1</code> and <code>t2</code> which are
 dominated by this node, returns their "join node": the node
 <code>j</code> such that <code>j</code> dominates both
 <code>t1</code> and <code>t2</code>, and every other node which
 dominates both <code>t1</code> and <code>t2</code>
 dominates <code>j</code>.
 In the special case that t1 dominates t2, return t1, and vice versa.
 Return <code>null</code> if no such node can be found.</div>
</li>
</ul>
<a name="cCommands-edu.stanford.nlp.trees.Tree-edu.stanford.nlp.trees.Tree-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>cCommands</h4>
<pre>public&nbsp;boolean&nbsp;cCommands(<a href="../../../../edu/stanford/nlp/trees/Tree.html" title="class in edu.stanford.nlp.trees">Tree</a>&nbsp;t1,
                         <a href="../../../../edu/stanford/nlp/trees/Tree.html" title="class in edu.stanford.nlp.trees">Tree</a>&nbsp;t2)</pre>
<div class="block">Given nodes <code>t1</code> and <code>t2</code> which are
 dominated by this node, returns <code>true</code> iff
 <code>t1</code> c-commands <code>t2</code>.  (A node c-commands
 its sister(s) and any nodes below its sister(s).)</div>
</li>
</ul>
<a name="siblings-edu.stanford.nlp.trees.Tree-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>siblings</h4>
<pre>public&nbsp;java.util.List&lt;<a href="../../../../edu/stanford/nlp/trees/Tree.html" title="class in edu.stanford.nlp.trees">Tree</a>&gt;&nbsp;siblings(<a href="../../../../edu/stanford/nlp/trees/Tree.html" title="class in edu.stanford.nlp.trees">Tree</a>&nbsp;root)</pre>
<div class="block">Returns the siblings of this Tree node.  The siblings are all
 children of the parent of this node except this node.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>root</code> - The root within which this tree node is contained</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>The siblings as a list, an empty list if there are no siblings.
   The returned list is a modifiable new list structure, but contains
   the actual children.</dd>
</dl>
</li>
</ul>
<a name="insertDtr-edu.stanford.nlp.trees.Tree-int-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>insertDtr</h4>
<pre>public&nbsp;void&nbsp;insertDtr(<a href="../../../../edu/stanford/nlp/trees/Tree.html" title="class in edu.stanford.nlp.trees">Tree</a>&nbsp;dtr,
                      int&nbsp;position)</pre>
<div class="block">insert <code>dtr</code> after <code>position</code> existing
 daughters in <code>this</code>.</div>
</li>
</ul>
<a name="value--">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>value</h4>
<pre>public&nbsp;java.lang.String&nbsp;value()</pre>
<div class="block"><span class="descfrmTypeLabel">Description copied from interface:&nbsp;<code><a href="../../../../edu/stanford/nlp/ling/Label.html#value--">Label</a></code></span></div>
<div class="block">Return a String representation of just the "main" value of this label.</div>
<dl>
<dt><span class="overrideSpecifyLabel">Specified by:</span></dt>
<dd><code><a href="../../../../edu/stanford/nlp/ling/Label.html#value--">value</a></code>&nbsp;in interface&nbsp;<code><a href="../../../../edu/stanford/nlp/ling/Label.html" title="interface in edu.stanford.nlp.ling">Label</a></code></dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>the "value" of the label</dd>
</dl>
</li>
</ul>
<a name="setValue-java.lang.String-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>setValue</h4>
<pre>public&nbsp;void&nbsp;setValue(java.lang.String&nbsp;value)</pre>
<div class="block"><span class="descfrmTypeLabel">Description copied from interface:&nbsp;<code><a href="../../../../edu/stanford/nlp/ling/Label.html#setValue-java.lang.String-">Label</a></code></span></div>
<div class="block">Set the value for the label (if one is stored).</div>
<dl>
<dt><span class="overrideSpecifyLabel">Specified by:</span></dt>
<dd><code><a href="../../../../edu/stanford/nlp/ling/Label.html#setValue-java.lang.String-">setValue</a></code>&nbsp;in interface&nbsp;<code><a href="../../../../edu/stanford/nlp/ling/Label.html" title="interface in edu.stanford.nlp.ling">Label</a></code></dd>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>value</code> - - the value for the label</dd>
</dl>
</li>
</ul>
<a name="setFromString-java.lang.String-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>setFromString</h4>
<pre>public&nbsp;void&nbsp;setFromString(java.lang.String&nbsp;labelStr)</pre>
<div class="block"><span class="descfrmTypeLabel">Description copied from interface:&nbsp;<code><a href="../../../../edu/stanford/nlp/ling/Label.html#setFromString-java.lang.String-">Label</a></code></span></div>
<div class="block">Set the contents of this label to this <code>String</code>
 representing the
 complete contents of the label.  A class implementing label may
 throw an <code>UnsupportedOperationException</code> for this
 method (only).  Typically, this method would do
 some appropriate decoding of the string in a way that sets
 multiple fields in an inverse of the <code>toString()</code>
 method.</div>
<dl>
<dt><span class="overrideSpecifyLabel">Specified by:</span></dt>
<dd><code><a href="../../../../edu/stanford/nlp/ling/Label.html#setFromString-java.lang.String-">setFromString</a></code>&nbsp;in interface&nbsp;<code><a href="../../../../edu/stanford/nlp/ling/Label.html" title="interface in edu.stanford.nlp.ling">Label</a></code></dd>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>labelStr</code> - the String that translates into the content of the
                 label</dd>
</dl>
</li>
</ul>
<a name="labelFactory--">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>labelFactory</h4>
<pre>public&nbsp;<a href="../../../../edu/stanford/nlp/ling/LabelFactory.html" title="interface in edu.stanford.nlp.ling">LabelFactory</a>&nbsp;labelFactory()</pre>
<div class="block">Returns a factory that makes labels of the same type as this one.
 May return <code>null</code> if no appropriate factory is known.</div>
<dl>
<dt><span class="overrideSpecifyLabel">Specified by:</span></dt>
<dd><code><a href="../../../../edu/stanford/nlp/ling/Label.html#labelFactory--">labelFactory</a></code>&nbsp;in interface&nbsp;<code><a href="../../../../edu/stanford/nlp/ling/Label.html" title="interface in edu.stanford.nlp.ling">Label</a></code></dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>the LabelFactory for this kind of label</dd>
</dl>
</li>
</ul>
<a name="leftCharEdge-edu.stanford.nlp.trees.Tree-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>leftCharEdge</h4>
<pre>public&nbsp;int&nbsp;leftCharEdge(<a href="../../../../edu/stanford/nlp/trees/Tree.html" title="class in edu.stanford.nlp.trees">Tree</a>&nbsp;node)</pre>
<div class="block">Returns the positional index of the left edge of  <i>node</i> within the tree,
 as measured by characters.  Returns -1 if <i>node is not found.</i>
 Note: These methods were written for internal evaluation routines. They are
 not the right methods to relate tree nodes to textual offsets. For these,
 look at the appropriate annotations on a CoreLabel (CharacterOffsetBeginAnnotation, etc.).</div>
</li>
</ul>
<a name="rightCharEdge-edu.stanford.nlp.trees.Tree-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>rightCharEdge</h4>
<pre>public&nbsp;int&nbsp;rightCharEdge(<a href="../../../../edu/stanford/nlp/trees/Tree.html" title="class in edu.stanford.nlp.trees">Tree</a>&nbsp;node)</pre>
<div class="block">Returns the positional index of the right edge of  <i>node</i> within the tree,
 as measured by characters. Returns -1 if <i>node is not found.</i>

 rightCharEdge returns the index of the rightmost character + 1, so that
 rightCharEdge(getLeaves().get(i)) == leftCharEdge(getLeaves().get(i+1))

 Note: These methods were written for internal evaluation routines. They are
 not the right methods to relate tree nodes to textual offsets. For these,
 look at the appropriate annotations on a CoreLabel (CharacterOffsetBeginAnnotation, etc.).</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>node</code> - The subtree to look for in this Tree</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>The positional index of the right edge of node</dd>
</dl>
</li>
</ul>
<a name="nodeNumber-edu.stanford.nlp.trees.Tree-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>nodeNumber</h4>
<pre>public&nbsp;int&nbsp;nodeNumber(<a href="../../../../edu/stanford/nlp/trees/Tree.html" title="class in edu.stanford.nlp.trees">Tree</a>&nbsp;root)</pre>
<div class="block">Calculates the node's <i>number</i>, defined as the number of nodes traversed in a left-to-right, depth-first search of the
 tree starting at <code>root</code> and ending at <code>this</code>.  Returns -1 if <code>root</code> does not contain <code>this</code>.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>root</code> - the root node of the relevant tree</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>the number of the current node, or -1 if <code>root</code> does not contain <code>this</code>.</dd>
</dl>
</li>
</ul>
<a name="getNodeNumber-int-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>getNodeNumber</h4>
<pre>public&nbsp;<a href="../../../../edu/stanford/nlp/trees/Tree.html" title="class in edu.stanford.nlp.trees">Tree</a>&nbsp;getNodeNumber(int&nbsp;i)</pre>
<div class="block">Fetches the <code>i</code>th node in the tree, with node numbers defined
 as in <a href="../../../../edu/stanford/nlp/trees/Tree.html#nodeNumber-edu.stanford.nlp.trees.Tree-"><code>nodeNumber(Tree)</code></a>.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>i</code> - the node number to fetch</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>the <code>i</code>th node in the tree</dd>
<dt><span class="throwsLabel">Throws:</span></dt>
<dd><code>java.lang.IndexOutOfBoundsException</code> - if <code>i</code> is not between 1 and
    the number of nodes (inclusive) contained in <code>this</code>.</dd>
</dl>
</li>
</ul>
<a name="indexLeaves--">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>indexLeaves</h4>
<pre>public&nbsp;void&nbsp;indexLeaves()</pre>
<div class="block">Assign sequential integer indices to the leaves of the tree
 rooted at this <code>Tree</code>, starting with 1.
 The leaves are traversed from left
 to right. If the node is already indexed, then it uses the existing index.
 This will only work if the leaves extend CoreMap.</div>
</li>
</ul>
<a name="indexLeaves-boolean-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>indexLeaves</h4>
<pre>public&nbsp;void&nbsp;indexLeaves(boolean&nbsp;overWrite)</pre>
<div class="block">Index the leaves, and optionally overwrite existing IndexAnnotations if they exist.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>overWrite</code> - Whether to replace an existing index for a leaf.</dd>
</dl>
</li>
</ul>
<a name="indexLeaves-int-boolean-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>indexLeaves</h4>
<pre>public&nbsp;int&nbsp;indexLeaves(int&nbsp;startIndex,
                       boolean&nbsp;overWrite)</pre>
<div class="block">Assign sequential integer indices to the leaves of the subtree
 rooted at this <code>Tree</code>, beginning with
 <code>startIndex</code>, and traversing the leaves from left
 to right. If node is already indexed, then it uses the existing index.
 This method only works if the labels of the tree implement
 CoreLabel!</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>startIndex</code> - index for this node</dd>
<dd><code>overWrite</code> - Whether to replace an existing index for a leaf.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>the next index still unassigned</dd>
</dl>
</li>
</ul>
<a name="percolateHeadIndices--">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>percolateHeadIndices</h4>
<pre>public&nbsp;void&nbsp;percolateHeadIndices()</pre>
<div class="block">Percolates terminal indices through a dependency tree. The terminals should be indexed, e.g.,
 by calling indexLeaves() on the tree.
 <p>
 This method assumes CoreLabels!</div>
</li>
</ul>
<a name="indexSpans--">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>indexSpans</h4>
<pre>public&nbsp;void&nbsp;indexSpans()</pre>
<div class="block">Index all spans (constituents) in the tree.
  For this, spans uses 0-based indexing and the span records the fencepost
  to the left of the first word and after the last word of the span.
  The spans are only recorded if the Tree has labels of a class which
  extends CoreMap.</div>
</li>
</ul>
<a name="indexSpans-int-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>indexSpans</h4>
<pre>public&nbsp;void&nbsp;indexSpans(int&nbsp;startIndex)</pre>
</li>
</ul>
<a name="indexSpans-edu.stanford.nlp.util.MutableInteger-">
<!--   -->
</a>
<ul class="blockListLast">
<li class="blockList">
<h4>indexSpans</h4>
<pre>public&nbsp;<a href="../../../../edu/stanford/nlp/util/Pair.html" title="class in edu.stanford.nlp.util">Pair</a>&lt;java.lang.Integer,java.lang.Integer&gt;&nbsp;indexSpans(<a href="../../../../edu/stanford/nlp/util/MutableInteger.html" title="class in edu.stanford.nlp.util">MutableInteger</a>&nbsp;startIndex)</pre>
<div class="block">Assigns span indices (BeginIndexAnnotation and EndIndexAnnotation) to all nodes in a tree.
 The beginning index is equivalent to the IndexAnnotation of the first leaf in the constituent.
 The end index is equivalent to the first integer after the IndexAnnotation of the last leaf in the constituent.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>startIndex</code> - Begin indexing at this value</dd>
</dl>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</div>
</div>
<!-- ========= END OF CLASS DATA ========= -->
<!-- ======= START OF BOTTOM NAVBAR ====== -->
<div class="bottomNav"><a name="navbar.bottom">
<!--   -->
</a>
<div class="skipNav"><a href="#skip.navbar.bottom" title="Skip navigation links">Skip navigation links</a></div>
<a name="navbar.bottom.firstrow">
<!--   -->
</a>
<ul class="navList" title="Navigation">
<li><a href="../../../../overview-summary.html">Overview</a></li>
<li><a href="package-summary.html">Package</a></li>
<li class="navBarCell1Rev">Class</li>
<li><a href="package-tree.html">Tree</a></li>
<li><a href="../../../../deprecated-list.html">Deprecated</a></li>
<li><a href="../../../../index-all.html">Index</a></li>
<li><a href="../../../../help-doc.html">Help</a></li>
</ul>
</div>
<div class="subNav">
<ul class="navList">
<li><a href="../../../../edu/stanford/nlp/trees/TransformingTreebank.html" title="class in edu.stanford.nlp.trees"><span class="typeNameLink">Prev&nbsp;Class</span></a></li>
<li><a href="../../../../edu/stanford/nlp/trees/Treebank.html" title="class in edu.stanford.nlp.trees"><span class="typeNameLink">Next&nbsp;Class</span></a></li>
</ul>
<ul class="navList">
<li><a href="../../../../index.html?edu/stanford/nlp/trees/Tree.html" target="_top">Frames</a></li>
<li><a href="Tree.html" target="_top">No&nbsp;Frames</a></li>
</ul>
<ul class="navList" id="allclasses_navbar_bottom">
<li><a href="../../../../allclasses-noframe.html">All&nbsp;Classes</a></li>
</ul>
<div>
<script type="text/javascript"><!--
  allClassesLink = document.getElementById("allclasses_navbar_bottom");
  if(window==top) {
    allClassesLink.style.display = "block";
  }
  else {
    allClassesLink.style.display = "none";
  }
  //-->
</script>
</div>
<div>
<ul class="subNavList">
<li>Summary:&nbsp;</li>
<li>Nested&nbsp;|&nbsp;</li>
<li><a href="#field.summary">Field</a>&nbsp;|&nbsp;</li>
<li><a href="#constructor.summary">Constr</a>&nbsp;|&nbsp;</li>
<li><a href="#method.summary">Method</a></li>
</ul>
<ul class="subNavList">
<li>Detail:&nbsp;</li>
<li><a href="#field.detail">Field</a>&nbsp;|&nbsp;</li>
<li><a href="#constructor.detail">Constr</a>&nbsp;|&nbsp;</li>
<li><a href="#method.detail">Method</a></li>
</ul>
</div>
<a name="skip.navbar.bottom">
<!--   -->
</a></div>
<!-- ======== END OF BOTTOM NAVBAR ======= -->
<p class="legalCopy"><small><FONT SIZE=2><A HREF="http://nlp.stanford.edu">Stanford NLP Group</A></FONT></small></p>
</body>
</html>
